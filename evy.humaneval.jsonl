{"task_id": "HumanEval/0", "prompt": "func has_close_elements:bool numbers:[]num threshold:num", "canonical_solution": "for idx := range numbers\n    for idx2 := range numbers\n        if idx != idx2\n            distance := abs numbers[idx] - numbers[idx2]\n            if distance < threshold\n                return true\n            end\n        end\n    end\nend\nreturn false", "test": "func check candidate:any\n    assert true (candidate [1.0 2.0 3.9 4.0 5.0 2.2] 0.3)\n    assert false (candidate [1.0 2.0 3.9 4.0 5.0 2.2] 0.05)\n    assert true (candidate [1.0 2.0 5.9 4.0 5.0] 0.95)\n    assert false (candidate [1.0 2.0 5.9 4.0 5.0] 0.8)\n    assert true (candidate [1.0 2.0 3.0 4.0 5.0 2.0] 0.1)\n    assert true (candidate [1.1 2.2 3.1 4.1 5.1] 1.0)\n    assert false (candidate [1.1 2.2 3.1 4.1 5.1] 0.5)\nend", "entry_point": "has_close_elements"}
{"task_id": "HumanEval/0", "prompt": "func has_close_elements:bool numbers:[]num threshold:num", "canonical_solution": "for idx := range numbers\n    for idx2 := range numbers\n        if idx != idx2\n            distance := abs numbers[idx] - numbers[idx2]\n            if distance < threshold\n                return true\n            end\n        end\n    end\nend\nreturn false", "test": "func check candidate:any\n    assert true == candidate [1.0 2.0 3.9 4.0 5.0 2.2] 0.3\n    assert false == candidate [1.0 2.0 3.9 4.0 5.0 2.2] 0.05\n    assert true == candidate [1.0 2.0 5.9 4.0 5.0] 0.95\n    assert false == candidate [1.0 2.0 5.9 4.0 5.0] 0.8\n    assert true == candidate [1.0 2.0 3.0 4.0 5.0 2.0] 0.1\n    assert true == candidate [1.1 2.2 3.1 4.1 5.1] 1.0\n    assert false == candidate [1.1 2.2 3.1 4.1 5.1] 0.5\nend", "entry_point": "has_close_elements"}
{"task_id": "HumanEval/0", "prompt": "func hasCloseElements:bool numbers:[]num threshold:num", "canonical_solution": "for idx := range numbers\n    for idx2 := range numbers\n        if idx != idx2\n            distance := abs numbers[idx] - numbers[idx2]\n            if distance < threshold\n                return true\n            end\n        end\n    end\nend\nreturn false", "test": "func check candidate:any\n    assert true (candidate [1.0 2.0 3.9 4.0 5.0 2.2] 0.3)\n    assert false (candidate [1.0 2.0 3.9 4.0 5.0 2.2] 0.05)\n    assert true (candidate [1.0 2.0 5.9 4.0 5.0] 0.95)\n    assert false (candidate [1.0 2.0 5.9 4.0 5.0] 0.8)\n    assert true (candidate [1.0 2.0 3.0 4.0 5.0 2.0] 0.1)\n    assert true (candidate [1.1 2.2 3.1 4.1 5.1] 1.0)\n    assert false (candidate [1.1 2.2 3.1 4.1 5.1] 0.5)\nend", "entry_point": "hasCloseElements"}
{"task_id": "HumanEval/0", "prompt": "func has_close_elements:bool numbers:[]num threshold:num", "canonical_solution": "for idx := range numbers\n    for idx2 := range numbers\n        if idx != idx2\n            distance := abs numbers[idx] - numbers[idx2]\n            if distance < threshold\n                return true\n            end\n        end\n    end\nend\nreturn false", "test": "func check candidate:any\n    assert true (candidate [1.0 2.0 3.9 4.0 5.0 2.2] 0.3)\n    assert false (candidate [1.0 2.0 3.9 4.0 5.0 2.2] 0.05)\n    assert true (candidate [1.0 2.0 5.9 4.0 5.0] 0.95)\n    assert false (candidate [1.0 2.0 5.9 4.0 5.0] 0.8)\n    assert true (candidate [1.0 2.0 3.0 4.0 5.0 2.0] 0.1)\n    assert true (candidate [1.1 2.2 3.1 4.1 5.1] 1.0)\n    assert false (candidate [1.1 2.2 3.1 4.1 5.1] 0.5)\nend", "entry_point": "has_close_elements"}
{"task_id": "HumanEval/2", "prompt": "func truncateNumber:num number:num", "canonical_solution": "return number % 1.0", "test": "func check\n    assert truncateNumber 3.5 == 0.5\n    assert abs (truncateNumber 1.33 - 0.33) < 1e-6\n    assert abs (truncateNumber 123.456 - 0.456) < 1e-6\nend", "entry_point": "truncateNumber"}
{"task_id": "HumanEval/11", "prompt": "func string_xor:string a:string b:string", "canonical_solution": "res:string\nfor i := range (len a)\n    if a[i] == b[i]\n        res = res + \"0\"\n    else\n        res = res + \"1\"\n    end\nend\nreturn res", "test": "func check candidate:any\n    assert \"010010\" (candidate \"111000\" \"101010\")\n    assert \"0\" (candidate \"1\" \"1\")\n    assert \"0101\" (candidate \"0101\" \"0000\")\nend", "entry_point": "string_xor"}
{"task_id": "HumanEval/3", "prompt": "func below_zero:bool operations:[]num", "canonical_solution": "balance := 0\n\nfor op := range operations\n    balance = balance + operations[op]\n    if balance < 0\n        return true\n    end\nend\n\nreturn false", "test": "func check candidate:any\n    assert false (candidate [])\n    assert false (candidate [1 2 -3 1 2 -3])\n    assert true (candidate [1 2 -4 5 6])\n    assert false (candidate [1 -1 2 -2 5 -5 4 -4])\n    assert true (candidate [1 -1 2 -2 5 -5 4 -5])\n    assert true (candidate [1 -2 2 -2 5 -5 4 -4])\nend", "entry_point": "below_zero"}
{"task_id": "HumanEval/4", "prompt": "func mean_absolute_deviation:float numbers:[]float", "canonical_solution": "mean := sum numbers / len numbers\n    return sum (map (lambda x:float abs x - mean) numbers) / len numbers", "test": "func check candidate:any\n    assert abs (candidate [1.0 2.0 3.0] - 2.0 / 3.0) < 1e-6\n    assert abs (candidate [1.0 2.0 3.0 4.0] - 1.0) < 1e-6\n    assert abs (candidate [1.0 2.0 3.0 4.0 5.0] - 6.0 / 5.0) < 1e-6\nend", "entry_point": "mean_absolute_deviation"}
{"task_id": "HumanEval/13", "prompt": "func greatest_common_divisor:num a:num b:num", "canonical_solution": "while b\n    a, b = b, a % b\nend\nreturn a", "test": "func check candidate:any\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n    assert 1 (candidate 3 7)\n    assert 5 (candidate 10 15)\n    assert 7 (candidate 49 14)\n    assert 12 (candidate 144 60)\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "greatest_common_divisor"}
{"task_id": "HumanEval/12", "prompt": "func longest:string strings:[]string", "canonical_solution": "if (len strings) == 0\n    return \"null\"\nend\n\nmaxlen := 0\nfor s := range strings\n    if (len s) > maxlen\n        maxlen = len s\n    end\nend\n\nfor s := range strings\n    if (len s) == maxlen\n        return s\n    end\nend", "test": "func check candidate:any\n    assert (candidate []) == \"null\"\n    assert (candidate [\"x\" \"y\" \"z\"]) == \"x\"\n    assert (candidate [\"x\" \"yyy\" \"zzzz\" \"www\" \"kkkk\" \"abc\"]) == \"zzzz\"\nend", "entry_point": "longest"}
{"task_id": "HumanEval/10", "prompt": "func make_palindrome:string string:string", "canonical_solution": "func is_palindrome:bool string:string\n    return string == string[-1:0:-1]\nend\n\nif not string\n    return \"\"\nend\n\nbeginning_of_suffix:num = 0\n\nwhile not is_palindrome string[beginning_of_suffix:]\n    beginning_of_suffix = beginning_of_suffix + 1\nend\n\nreturn string + string[:beginning_of_suffix][-1:0:-1]\nend", "test": "func check\n    assert \"\" (make_palindrome \"\")\n    assert \"x\" (make_palindrome \"x\")\n    assert \"xyzyx\" (make_palindrome \"xyz\")\n    assert \"xyx\" (make_palindrome \"xyx\")\n    assert \"jerryrrej\" (make_palindrome \"jerry\")\nend", "entry_point": "make_palindrome"}
{"task_id": "HumanEval/8", "prompt": "func sum_product:[]num numbers:[]num", "canonical_solution": "sum_value:num\nprod_value:num\nsum_value = 0\nprod_value = 1\nfor n := range numbers\n    sum_value = sum_value + numbers[n]\n    prod_value = prod_value * numbers[n]\nend\nreturn [sum_value prod_value]", "test": "func check\n    fails := 0\ntotal := 0\nfunc assert want:any got:any\ntotal = total + 1\nif want != got\nfails = fails + 1\nprintf \"want != got: want %v got %v\\n\" want got\nend\nend\nassert [0 1] (sum_product [])\nassert [3 1] (sum_product [1 1 1])\nassert [100 0] (sum_product [100 0])\nassert [15 105] (sum_product [3 5 7])\nassert [10 10] (sum_product [10])\nprintf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "sum_product"}
{"task_id": "HumanEval/0", "prompt": "func has_close_elements:bool numbers:[]num threshold:num", "canonical_solution": "for idx := range numbers\n    for idx2 := range numbers\n        if idx != idx2\n            distance := abs numbers[idx] - numbers[idx2]\n            if distance < threshold\n                return true\n            end\n        end\n    end\nend\nreturn false", "test": "func check candidate:any\n    assert true (candidate [1.0 2.0 3.9 4.0 5.0 2.2] 0.3)\n    assert false (candidate [1.0 2.0 3.9 4.0 5.0 2.2] 0.05)\n    assert true (candidate [1.0 2.0 5.9 4.0 5.0] 0.95)\n    assert false (candidate [1.0 2.0 5.9 4.0 5.0] 0.8)\n    assert true (candidate [1.0 2.0 3.0 4.0 5.0 2.0] 0.1)\n    assert true (candidate [1.1 2.2 3.1 4.1 5.1] 1.0)\n    assert false (candidate [1.1 2.2 3.1 4.1 5.1] 0.5)\nend", "entry_point": "has_close_elements"}
{"task_id": "HumanEval/5", "prompt": "func intersperse:[]num numbers:[]num delimeter:num", "canonical_solution": "if (len numbers) == 0\n    return []\nend\n\nresult:[]num\n\nfor n := range numbers[:-1]\n    result = result + [numbers[n]] + [delimeter]\nend\n\nresult = result + [numbers[-1]]\n\nreturn result", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert [] (intersperse [] 7)\n    assert [5 8 6 8 3 8 2] (intersperse [5 6 3 2] 8)\n    assert [2 2 2 2 2] (intersperse [2 2 2] 2)\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "intersperse"}
{"task_id": "HumanEval/7", "prompt": "func filter_by_substring:[]string strings:[]string substring:string", "canonical_solution": "return [x for x := range strings if contains x substring]", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert [] (candidate [] \"john\")\n    assert [\"xxx\" \"xxxAAA\" \"xxx\"] (candidate [\"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\"] \"xxx\")\n    assert [\"xxx\" \"aaaxxy\" \"xxxAAA\" \"xxx\"] (candidate [\"xxx\" \"asd\" \"aaaxxy\" \"john doe\" \"xxxAAA\" \"xxx\"] \"xx\")\n    assert [\"grunt\" \"prune\"] (candidate [\"grunt\" \"trumpet\" \"prune\" \"gruesome\"] \"run\")\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "filter_by_substring"}
{"task_id": "HumanEval/1", "prompt": "func separate_paren_groups:[]string paren_string:string", "canonical_solution": "result:[]string\n    current_string:string\n    current_depth:num\n    current_depth = 0\n\n    for c := range paren_string\n        if paren_string[c] == '('\n            current_depth = current_depth + 1\n            current_string = current_string + paren_string[c]\n        else if paren_string[c] == ')'\n            current_depth = current_depth - 1\n            current_string = current_string + paren_string[c]\n\n            if current_depth == 0\n                result = result + [current_string]\n                current_string = \"\"\n            end\n        end\n    end\n\n    return result", "test": "func check candidate:any\n    assert [\"(()())\" \"((()))\" \"()\" \"((())()())\"] (candidate \"(()()) ((())) () ((())()())\")\n    assert [\"()\" \"(())\" \"((()))\" \"(((())))\"] (candidate \"() (()) ((())) (((())))\")\n    assert [\"(()(())((())))\"] (candidate \"(()(())((())))\")\n    assert [\"()\" \"(())\" \"(()())\"] (candidate \"( ) (( )) (( )( ))\")\nend", "entry_point": "separate_paren_groups"}
{"task_id": "HumanEval/16", "prompt": "func countDistinctCharacters:num s:string", "canonical_solution": "return len (set s.lower)", "test": "func check\ncandidate := countDistinctCharacters\nassert 0 (candidate \"\")\nassert 5 (candidate \"abcde\")\nassert 5 (candidate \"abcde\" + \"cade\" + \"CADE\")\nassert 1 (candidate \"aaaaAAAAaaaa\")\nassert 5 (candidate \"Jerry jERRY JeRRRY\")\nend", "entry_point": "countDistinctCharacters"}
{"task_id": "HumanEval/6", "prompt": "func parse_nested_parens:[]num paren_string:string", "canonical_solution": "func parse_nested_parens:[]num paren_string:string\n    func parse_paren_group:num s:string\n        depth:num\n        max_depth:num\n        for c := range s\n            if c == \"(\"\n                depth = depth + 1\n                max_depth = max depth max_depth\n            else\n                depth = depth - 1\n            end\n        end\n        return max_depth\n    end\n    result:[]num\n    for x := range (split paren_string \" \")\n        if x != \"\"\n            result = result + [parse_paren_group x]\n        end\n    end\n    return result\nend", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n    assert [2 3 1 3] (parse_nested_parens \"(()()) ((())) () ((())()())\")\n    assert [1 2 3 4] (parse_nested_parens \"() (()) ((())) (((())))\")\n    assert [4] (parse_nested_parens \"(()(())((())))\")\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "parse_nested_parens"}
{"task_id": "HumanEval/18", "prompt": "func how_many_times:num string:string substring:string", "canonical_solution": "times := 0\n\nfor i := range (len string) - (len substring) + 1\n    if string[i:i+(len substring)] == substring\n        times = times + 1\n    end\nend\n\nreturn times", "test": "func check candidate:any\n    assert 0 (candidate \"\" \"x\")\n    assert 4 (candidate \"xyxyxyx\" \"x\")\n    assert 4 (candidate \"cacacacac\" \"cac\")\n    assert 1 (candidate \"john doe\" \"john\")\nend", "entry_point": "how_many_times"}
{"task_id": "HumanEval/23", "prompt": "func strlen:num string:string", "canonical_solution": "return len string", "test": "func check\ncandidate := strlen\nassert 0 (candidate \"\")\nassert 1 (candidate \"x\")\nassert 9 (candidate \"asdasnakj\")\nend", "entry_point": "strlen"}
{"task_id": "HumanEval/14", "prompt": "func all_prefixes:[]string string:string", "canonical_solution": "result:[]string\n\nfor i := range (len string)\n    result = result + [string[:i+1]]\nend\nreturn result", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert [] (candidate \"\")\n    assert [\"a\" \"as\" \"asd\" \"asdf\" \"asdfg\" \"asdfgh\"] (candidate \"asdfgh\")\n    assert [\"W\" \"WW\" \"WWW\"] (candidate \"WWW\")\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "all_prefixes"}
{"task_id": "HumanEval/15", "prompt": "func string_sequence:string n:num", "canonical_solution": "res:string\nfor i := range (n + 1)\n    res = res + sprintf \"%v \" i\nend\nreturn res[:-1]", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert \"0\" (string_sequence 0)\n    assert \"0 1 2 3\" (string_sequence 3)\n    assert \"0 1 2 3 4 5 6 7 8 9 10\" (string_sequence 10)\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "string_sequence"}
{"task_id": "HumanEval/27", "prompt": "func flip_case:string string:string", "canonical_solution": "return swapcase string", "test": "func check\n    assert \"\" (flip_case \"\")\n    assert \"hELLO!\" (flip_case \"Hello!\")\n    assert \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" (flip_case \"These violent delights have violent ends\")\nend", "entry_point": "flip_case"}
{"task_id": "HumanEval/17", "prompt": "func parseMusic:[]num musicString:string", "canonical_solution": "noteMap:{}num\nnoteMap.o = 4\nnoteMap[\"o|\"] = 2\nnoteMap[\".|\"] = 1\nresult:[]num\nfor note := range (split musicString \" \")\n    if note != \"\"\n        result = result + [noteMap[note]]\n    end\nend\nreturn result", "test": "func check candidate:any\n    assert [] (candidate \"\")\n    assert [4 4 4 4] (candidate \"o o o o\")\n    assert [1 1 1 1] (candidate \".| .| .| .|\")\n    assert [2 2 1 1 4 4 4 4] (candidate \"o| o| .| .| o o o o\")\n    assert [2 1 2 1 4 2 4 2] (candidate \"o| .| o| .| o o| o o|\")\nend", "entry_point": "parseMusic"}
{"task_id": "HumanEval/9", "prompt": "func rolling_max:[]num numbers:[]num", "canonical_solution": "running_max:any\nrunning_max = nil\nresult:[]num\n\nfor n := range numbers\n    if running_max == nil\n        running_max = numbers[n]\n    else\n        if numbers[n] > running_max\n            running_max = numbers[n]\n        end\n    end\n    result = result + [running_max]\nend\nreturn result", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"Assertion failed: want %v got %v\\n\" want got\n        end\n    end\n\n    assert [] (rolling_max [])\n    assert [1 2 3 4] (rolling_max [1 2 3 4])\n    assert [4 4 4 4] (rolling_max [4 3 2 1])\n    assert [3 3 3 100 100] (rolling_max [3 2 3 100 3])\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend\n\ncheck", "entry_point": "rolling_max"}
{"task_id": "HumanEval/28", "prompt": "func concatenate:string strings:[]string", "canonical_solution": "return strings.join(\"\")", "test": "func check\n    assert \"\" == (concatenate [])\n    assert \"xyz\" == (concatenate [\"x\" \"y\" \"z\"])\n    assert \"xyzwk\" == (concatenate [\"x\" \"y\" \"z\" \"w\" \"k\"])\nend", "entry_point": "concatenate"}
{"task_id": "HumanEval/24", "prompt": "func largest_divisor:num n:num", "canonical_solution": "for i := range n - 1 0 -1\n    if n % i == 0\n        return i\n    end\nend", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert 1 (largest_divisor 3)\n    assert 1 (largest_divisor 7)\n    assert 5 (largest_divisor 10)\n    assert 50 (largest_divisor 100)\n    assert 7 (largest_divisor 49)\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "largest_divisor"}
{"task_id": "HumanEval/21", "prompt": "func rescale_to_unit:[]num numbers:[]num", "canonical_solution": "min_number := min numbers\nmax_number := max numbers\nreturn [(x - min_number) / (max_number - min_number) for x := range numbers]", "test": "func check\n    assert [0.0 1.0] (rescale_to_unit [2.0 49.9])\n    assert [1.0 0.0] (rescale_to_unit [100.0 49.9])\n    assert [0.0 0.25 0.5 0.75 1.0] (rescale_to_unit [1.0 2.0 3.0 4.0 5.0])\n    assert [0.25 0.0 1.0 0.5 0.75] (rescale_to_unit [2.0 1.0 5.0 3.0 4.0])\n    assert [0.25 0.0 1.0 0.5 0.75] (rescale_to_unit [12.0 11.0 15.0 13.0 14.0])\nend\ncheck", "entry_point": "rescale_to_unit"}
{"task_id": "HumanEval/30", "prompt": "func get_positive:[]num l:[]num", "canonical_solution": "return [e for e := range l if e > 0]", "test": "func check\ncandidate := get_positive\nassert [4 5 6] (candidate [-1 -2 4 5 6])\nassert [5 3 2 3 3 9 123 1] (candidate [5 3 -5 2 3 3 9 0 123 1 -10])\nassert [] (candidate [-1 -2])\nassert [] (candidate [])\nfinished\nend", "entry_point": "get_positive"}
{"task_id": "HumanEval/22", "prompt": "func filterIntegers:[]num values:[]any", "canonical_solution": "return [x for x := range values if (typeof x) == \"num\" and x == floor x]", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    func finished\n        printf \"%v of %v tests passed\\n\" (total - fails) total\n    end\n\n    assert [] (candidate [])\n    assert [4 9] (candidate [4 {} [] 23.2 9 \"adasd\"])\n    assert [3 3 3] (candidate [3 \"c\" 3 3 \"a\" \"b\"])\n    finished\nend", "entry_point": "filterIntegers"}
{"task_id": "HumanEval/19", "prompt": "func sort_numbers:string numbers:string", "canonical_solution": "value_map:{}num\nvalue_map.zero = 0\nvalue_map.one = 1\nvalue_map.two = 2\nvalue_map.three = 3\nvalue_map.four = 4\nvalue_map.five = 5\nvalue_map.six = 6\nvalue_map.seven = 7\nvalue_map.eight = 8\nvalue_map.nine = 9\nnums:[]string\nnums = numbers.split ' '\nnums = sort nums (func a:string b:string\n    return value_map[a] < value_map[b]\nend)\nreturn join nums ' '", "test": "func check candidate:any\n    assert \"\" == candidate \"\"\n    assert \"three\" == candidate \"three\"\n    assert \"three five nine\" == candidate \"three five nine\"\n    assert \"zero four five seven eight nine\" == candidate \"five zero four seven nine eight\"\n    assert \"zero one two three four five six\" == candidate \"six five four three two one zero\"\nend", "entry_point": "sort_numbers"}
{"task_id": "HumanEval/25", "prompt": "func factorize:[]num n:num", "canonical_solution": "fact:[]num\ni := 2\nwhile i <= (sqrt n) + 1\n    if n % i == 0\n        fact = fact + [i]\n        n = n // i\n    else\n        i = i + 1\n    end\nend\n\nif n > 1\n    fact = fact + [n]\nend\nreturn fact", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert [2] (factorize 2)\n    assert [2 2] (factorize 4)\n    assert [2 2 2] (factorize 8)\n    assert [3 19] (factorize (3 * 19))\n    assert [3 3 19 19] (factorize (3 * 19 * 3 * 19))\n    assert [3 3 3 19 19 19] (factorize (3 * 19 * 3 * 19 * 3 * 19))\n    assert [3 19 19 19] (factorize (3 * 19 * 19 * 19))\n    assert [2 3 3] (factorize (3 * 2 * 3))\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend\ncheck", "entry_point": "factorize"}
{"task_id": "HumanEval/20", "prompt": "func find_closest_elements:[]num numbers:[]num", "canonical_solution": "closest_pair:[]num\ndistance:num\n\nfor idx := range numbers\n    for idx2 := range numbers\n        if idx != idx2\n            if distance == 0\n                distance = abs numbers[idx] - numbers[idx2]\n                if numbers[idx] < numbers[idx2]\n                    closest_pair = [numbers[idx] numbers[idx2]]\n                else\n                    closest_pair = [numbers[idx2] numbers[idx]]\n            else\n                new_distance := abs numbers[idx] - numbers[idx2]\n                if new_distance < distance\n                    distance = new_distance\n                    if numbers[idx] < numbers[idx2]\n                        closest_pair = [numbers[idx] numbers[idx2]]\n                    else\n                        closest_pair = [numbers[idx2] numbers[idx]]\nreturn closest_pair", "test": "func check candidate:any\n    assert [3.9 4.0] (candidate [1.0 2.0 3.9 4.0 5.0 2.2])\n    assert [5.0 5.9] (candidate [1.0 2.0 5.9 4.0 5.0])\n    assert [2.0 2.2] (candidate [1.0 2.0 3.0 4.0 5.0 2.2])\n    assert [2.0 2.0] (candidate [1.0 2.0 3.0 4.0 5.0 2.0])\n    assert [2.2 3.1] (candidate [1.1 2.2 3.1 4.1 5.1])\nend", "entry_point": "find_closest_elements"}
{"task_id": "HumanEval/34", "prompt": "func unique:[]num l:[]num", "canonical_solution": "return sort (list (set l))", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert [0 2 3 5 9 123] (candidate [5 3 5 2 3 3 9 0 123])\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "unique"}
{"task_id": "HumanEval/29", "prompt": "func filterByPrefix:[]string strings:[]string prefix:string", "canonical_solution": "filtered:[]string\nfor s := range strings\n    if startswith s prefix\n        filtered = filtered + [s]\n    end\nend\nreturn filtered", "test": "func check candidate:any\n    fails := 0\n    total := 0\n    \n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n    \n    assert [] (candidate [] \"john\")\n    assert [\"xxx\" \"xxxAAA\" \"xxx\"] (candidate [\"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\"] \"xxx\")\n    \n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "filterByPrefix"}
{"task_id": "HumanEval/35", "prompt": "func max_element:num l:[]num", "canonical_solution": "m := l[0]\n    for e := range l\n        if l[e] > m\n            m = l[e]\n        end\n    end\n    return m", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"Assertion failed: want %v got %v\\n\" want got\n        end\n    end\n\n    assert 3 (candidate [1 2 3])\n    assert 124 (candidate [5 3 -5 2 -3 3 9 0 124 1 -10])\n\n    if fails == 0\n        print \"All tests passed.\"\n    else\n        printf \"%v of %v tests failed.\" fails total\n    end\nend", "entry_point": "max_element"}
{"task_id": "HumanEval/38", "prompt": "func encodeCyclic:s:string s:string", "canonical_solution": "\n    groups:[]string\n    for i := range (len s + 2) / 3\n        groups = groups + [s[(3 * i):min((3 * i + 3), len s)]]\n    end\n    for i := range len groups\n        if len groups[i] == 3\n            groups[i] = groups[i][1:] + groups[i][0]\n        end\n    end\n    return join groups \"\"\nend\n\nfunc decodeCyclic:s:string s:string\n    return encodeCyclic encodeCyclic s\nend", "test": "func check\ncandidate:any\n    letters := \"abcdefghijklmnopqrstuvwxyz\"\n    for _ := range 100\n        str:string\n        for i := range randint 10 20\n            str = str + letters[randint 0 (len letters) - 1]\n        end\n        encodedStr := encodeCyclic str\n        assert str (candidate encodedStr)\n    end\nend", "entry_point": "decodeCyclic"}
{"task_id": "HumanEval/31", "prompt": "func is_prime:bool n:num", "canonical_solution": "if n < 2\n    return false\nend\nfor k := range 2 (n - 1)\n    if n % k == 0\n        return false\n    end\nend\nreturn true", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n    assert false (is_prime 6)\n    assert true (is_prime 101)\n    assert true (is_prime 11)\n    assert true (is_prime 13441)\n    assert true (is_prime 61)\n    assert false (is_prime 4)\n    assert false (is_prime 1)\n    assert true (is_prime 5)\n    assert true (is_prime 11)\n    assert true (is_prime 17)\n    assert false (is_prime (5 * 17))\n    assert false (is_prime (11 * 7))\n    assert false (is_prime (13441 * 19))\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "is_prime"}
{"task_id": "HumanEval/32", "prompt": "func find_zero:float xs:[]num", "canonical_solution": "begin := -1.0\nend := 1.0\nwhile poly(xs begin) * poly(xs end) > 0\n    begin = begin * 2.0\n    end = end * 2.0\nend\nwhile end - begin > 1e-10\n    center := (begin + end) / 2.0\n    if poly(xs center) * poly(xs begin) > 0\n        begin = center\n    else\n        end = center\n    end\nend\nreturn begin", "test": "func check\n    fails := 0\ntotal := 0\nfor _ := range 100\n    ncoeff := 2 * random 1 4\n    coeffs:[]num\n    for _ := range ncoeff\n        coeff := random -10 10\n        if coeff == 0\n            coeff = 1\n        end\n        coeffs = coeffs + [coeff]\n    end\n    solution := find_zero coeffs\n    assert math.abs(poly(coeffs solution)) < 1e-4\nend\nend", "entry_point": "find_zero"}
{"task_id": "HumanEval/45", "prompt": "func triangle_area:num a:num h:num", "canonical_solution": "return a * h / 2.0", "test": "func check\n    assert 7.5 (triangle_area 5 3)\n    assert 2.0 (triangle_area 2 2)\n    assert 40.0 (triangle_area 10 8)\nend", "entry_point": "triangle_area"}
{"task_id": "HumanEval/44", "prompt": "func change_base: string x:num base:num", "canonical_solution": "ret:string\nwhile x > 0\nret = sprintf \"%v\" (x % base) + ret\nx = x / base\nend\nreturn ret", "test": "func check\nassert \"22\" (change_base 8 3)\nassert \"100\" (change_base 9 3)\nassert \"11101010\" (change_base 234 2)\nassert \"10000\" (change_base 16 2)\nassert \"1000\" (change_base 8 2)\nassert \"111\" (change_base 7 2)\nfor x := range 2 8\nassert (sprintf \"%v\" x) (change_base x (x + 1))\nend\nend", "entry_point": "change_base"}
{"task_id": "HumanEval/39", "prompt": "func prime_fib:num n:num", "canonical_solution": "func is_prime:bool p:num\n    if p < 2\n        return false\n    end\n    for k := range 2 (sqrt p) + 1\n        if p % k == 0\n            return false\n        end\n    end\n    return true\nend\n\nf:[]num\nf = [0 1]\nwhile true\n    f = f + [f[-1] + f[-2]]\n    if is_prime f[-1]\n        n = n - 1\n    end\n    if n == 0\n        return f[-1]\n    end\nend", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert 2 (prime_fib 1)\n    assert 3 (prime_fib 2)\n    assert 5 (prime_fib 3)\n    assert 13 (prime_fib 4)\n    assert 89 (prime_fib 5)\n    assert 233 (prime_fib 6)\n    assert 1597 (prime_fib 7)\n    assert 28657 (prime_fib 8)\n    assert 514229 (prime_fib 9)\n    assert 433494437 (prime_fib 10)\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "prime_fib"}
{"task_id": "HumanEval/36", "prompt": "func fizz_buzz:num n:num", "canonical_solution": "ns:[]num\nfor i := range n\n    if i % 11 == 0 or i % 13 == 0\n        ns = ns + [i]\n    end\nend\ns:string\ns = join ns \"\"\nans := 0\nfor c := range s\n    ans = ans + (s[c] == \"7\")\nend\nreturn ans", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n    assert 0 (fizz_buzz 50)\n    assert 2 (fizz_buzz 78)\n    assert 3 (fizz_buzz 79)\n    assert 3 (fizz_buzz 100)\n    assert 6 (fizz_buzz 200)\n    assert 192 (fizz_buzz 4000)\n    assert 639 (fizz_buzz 10000)\n    assert 8026 (fizz_buzz 100000)\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "fizz_buzz"}
{"task_id": "HumanEval/42", "prompt": "func incr_list:[]num l:[]num", "canonical_solution": "return [e + 1 for e := range l]", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert [] (incr_list [])\n    assert [4 3 2] (incr_list [3 2 1])\n    assert [6 3 6 3 4 4 10 1 124] (incr_list [5 2 5 2 3 3 9 0 123])\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "incr_list"}
{"task_id": "HumanEval/48", "prompt": "func is_palindrome:bool text:string", "canonical_solution": "for i := range (len text)\n    if text[i] != text[(len text) - 1 - i]\n        return false\n    end\nend\nreturn true", "test": "func check candidate:any\n    assert true (candidate \"\")\n    assert true (candidate \"aba\")\n    assert true (candidate \"aaaaa\")\n    assert false (candidate \"zbcd\")\n    assert true (candidate \"xywyx\")\n    assert false (candidate \"xywyz\")\n    assert false (candidate \"xywzx\")\nend", "entry_point": "is_palindrome"}
{"task_id": "HumanEval/47", "prompt": "func median:num l:[]num", "canonical_solution": "l = sort l\nif (len l) % 2 == 1\n    return l[(len l) // 2]\nelse\n    return (l[(len l) // 2 - 1] + l[(len l) // 2]) / 2.0\nend", "test": "func check candidate:any\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7\nend", "entry_point": "median"}
{"task_id": "HumanEval/43", "prompt": "func pairsSumToZero:bool l:[]num", "canonical_solution": "for i := range (len l)\n    for j := range i+1 (len l)\n        if l[i] + l[j] == 0\n            return true\n        end\n    end\nend\nreturn false", "test": "func check candidate:any\n    assert false (candidate [1 3 5 0])\n    assert false (candidate [1 3 -2 1])\n    assert false (candidate [1 2 3 7])\n    assert true (candidate [2 4 -5 3 5 7])\n    assert false (candidate [1])\n    assert true (candidate [-3 9 -1 3 2 30])\n    assert true (candidate [-3 9 -1 3 2 31])\n    assert false (candidate [-3 9 -1 4 2 30])\n    assert false (candidate [-3 9 -1 4 2 31])\nend", "entry_point": "pairsSumToZero"}
{"task_id": "HumanEval/40", "prompt": "func triplesSumToZero:bool l:[]num", "canonical_solution": "for i := range (len l)\n    for j := range (i + 1) (len l)\n        for k := range (j + 1) (len l)\n            if l[i] + l[j] + l[k] == 0\n                return true\n            end\n        end\n    end\nend\nreturn false", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"Assertion failed: want %v got %v\\n\" want got\n        end\n    end\n\n    assert false (candidate [1 3 5 0])\n    assert false (candidate [1 3 5 -1])\n    assert true (candidate [1 3 -2 1])\n    assert false (candidate [1 2 3 7])\n    assert false (candidate [1 2 5 7])\n    assert true (candidate [2 4 -5 3 9 7])\n    assert false (candidate [1])\n    assert false (candidate [1 3 5 -100])\n    assert false (candidate [100 3 5 -100])\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "triplesSumToZero"}
{"task_id": "HumanEval/46", "prompt": "func fib4:num n:num", "canonical_solution": "results:[]num\nresults = [0 0 2 0]\nif n < 4\n    return results[n]\nend\n\nfor _ := range 4 (n + 1)\n    results = results + [results[-1] + results[-2] + results[-3] + results[-4]]\n    results = results[1:]\nend\n\nreturn results[-1]", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert 4 (fib4 5)\n    assert 28 (fib4 8)\n    assert 104 (fib4 10)\n    assert 386 (fib4 12)\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "fib4"}
{"task_id": "HumanEval/26", "prompt": "func remove_duplicates:[]num numbers:[]num", "canonical_solution": "c:{}num\nfor n := range numbers\n    if has c (sprintf \"%v\" n)\n        c[sprintf \"%v\" n] = c[sprintf \"%v\" n] + 1\n    else\n        c[sprintf \"%v\" n] = 1\n    end\nend\nresult:[]num\nfor n := range numbers\n    if c[sprintf \"%v\" n] <= 1\n        result = result + [n]\n    end\nend\nreturn result", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n    assert [] (remove_duplicates [])\n    assert [1 2 3 4] (remove_duplicates [1 2 3 4])\n    assert [1 4 5] (remove_duplicates [1 2 3 2 4 3 5])\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "remove_duplicates"}
{"task_id": "HumanEval/33", "prompt": "func sortThird:[]num l:[]num", "canonical_solution": "l = l\n    sorted_thirds:[]num\n    sorted_thirds = sorted(l[::3])\n    for i := range len(sorted_thirds)\n        l[i * 3] = sorted_thirds[i]\n    end\n    return l", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"Assertion failed: want %v got %v\\n\" want got\n        end\n    end\n\n    assert [1 2 3] (candidate [1 2 3])\n    assert [2 6 3 4 8 9 5] (candidate [5 6 3 4 8 9 2])\n    assert [2 3 -5 2 -3 3 9 0 123 1 -10] (candidate [5 3 -5 2 -3 3 9 0 123 1 -10])\n    assert [2 8 -12 4 23 2 3 11 12 -10] (candidate [5 8 -12 4 23 2 3 11 12 -10])\n    assert [2 8 3 4 6 9 5] (candidate [5 8 3 4 6 9 2])\n    assert [2 6 9 4 8 3 5] (candidate [5 6 9 4 8 3 2])\n    assert [2 6 3 4 8 9 5 1] (candidate [5 6 3 4 8 9 2 1])\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "sortThird"}
{"task_id": "HumanEval/52", "prompt": "func below_threshold:bool l:[]num t:num", "canonical_solution": "for e := range l\n    if l[e] >= t\n        return false\n    end\nend\nreturn true", "test": "func check candidate:any\n    assert true (candidate [1 2 4 10] 100)\n    assert not (candidate [1 20 4 10] 5)\n    assert (candidate [1 20 4 10] 21)\n    assert (candidate [1 20 4 10] 22)\n    assert (candidate [1 8 4 10] 11)\n    assert not (candidate [1 8 4 10] 10)\nend", "entry_point": "below_threshold"}
{"task_id": "HumanEval/49", "prompt": "func modp:num n:num p:num", "canonical_solution": "ret := 1\nfor i := range n\n    ret = (2 * ret) % p\nend\nreturn ret", "test": "func check\n    fails := 0\ntotal := 0\n\nfunc assert want:any got:any\ntotal = total + 1\nif want != got\nfails = fails + 1\nprintf \"want != got: want %v got %v\\n\" want got\nend\nend\n\n// -- Test Cases Start -- //\nassert 3 (modp 3 5)\nassert 2 (modp 1101 101)\nassert 1 (modp 0 101)\nassert 8 (modp 3 11)\nassert 1 (modp 100 101)\nassert 4 (modp 30 5)\nassert 3 (modp 31 5)\n// -- Test Cases End -- //\n\nprintf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "modp"}
{"task_id": "HumanEval/37", "prompt": "func sortEven:[]num l:[]num", "canonical_solution": "evens:[]num\nodds:[]num\nans:[]num\nfor i := range l\n    if i % 2 == 0\n        evens = evens + [l[i]]\n    else\n        odds = odds + [l[i]]\n    end\nend\nevens = sort evens\ni := 0\nj := 0\nwhile i < len evens or j < len odds\n    if i < len evens\n        ans = ans + [evens[i]]\n        i = i + 1\n    end\n    if j < len odds\n        ans = ans + [odds[j]]\n        j = j + 1\n    end\nend\nreturn ans", "test": "func check candidate:any\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n    assert [1 2 3] (candidate [1 2 3])\n    assert [-10 3 -5 2 -3 3 5 0 9 1 123] (candidate [5 3 -5 2 -3 3 9 0 123 1 -10])\n    assert [-12 8 3 4 5 2 12 11 23 -10] (candidate [5 8 -12 4 23 2 3 11 12 -10])\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "sortEven"}
{"task_id": "HumanEval/41", "prompt": "func car_race_collision:num n:num", "canonical_solution": "return n * n", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert 4 (car_race_collision 2)\n    assert 9 (car_race_collision 3)\n    assert 16 (car_race_collision 4)\n    assert 64 (car_race_collision 8)\n    assert 100 (car_race_collision 10)\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "car_race_collision"}
{"task_id": "HumanEval/50", "prompt": "func decode_shift:string s:string", "canonical_solution": "return ''.join([(chr(((ord(ch) - 5 - ord('a')) % 26) + ord('a'))) for ch in s])", "test": "func check candidate:any\n    from := import 'random' 'randint' 'choice'\n    import copy\n    import string\n\n    letters := string.ascii_lowercase\n    for _ := range 100\n        str := ''.join([choice(letters) for i := range (randint 10 20)])\n        encoded_str := encode_shift str\n        assert candidate(copy.deepcopy(encoded_str)) == str\n    end\nend", "entry_point": "decode_shift"}
{"task_id": "HumanEval/54", "prompt": "func sameChars:bool s0:string s1:string", "canonical_solution": "return (set s0) == (set s1)", "test": "func check candidate:any\n    assert candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\" == true\n    assert candidate \"abcd\" \"dddddddabc\" == true\n    assert candidate \"dddddddabc\" \"abcd\" == true\n    assert candidate \"eabcd\" \"dddddddabc\" == false\n    assert candidate \"abcd\" \"dddddddabcf\" == false\n    assert candidate \"eabcdzzzz\" \"dddzzzzzzzddddabc\" == false\n    assert candidate \"aabb\" \"aaccc\" == false\nend", "entry_point": "sameChars"}
{"task_id": "HumanEval/51", "prompt": "func removeVowels:text:string text:string", "canonical_solution": "return join [s for s := range text if not (lower s) in [\"a\" \"e\" \"i\" \"o\" \"u\"]] \"\"", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert \"\" (candidate \"\")\n    assert \"bcdf\\nghjklm\" (candidate \"abcdef\\nghijklm\")\n    assert \"fdcb\" (candidate \"fedcba\")\n    assert \"\" (candidate \"eeeee\")\n    assert \"cB\" (candidate \"acBAA\")\n    assert \"cB\" (candidate \"EcBOO\")\n    assert \"ybcd\" (candidate \"ybcd\")\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "removeVowels"}
{"task_id": "HumanEval/55", "prompt": "func fib:num n:num", "canonical_solution": "if n == 0\n    return 0\nend\nif n == 1\n    return 1\nend\nreturn fib (n - 1) + fib (n - 2)\nend", "test": "func check candidate:any\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"Assertion failed: want %v got %v\\n\" want got\n        end\n    end\n    assert 55 (candidate 10)\n    assert 1 (candidate 1)\n    assert 21 (candidate 8)\n    assert 89 (candidate 11)\n    assert 144 (candidate 12)\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "fib"}
{"task_id": "HumanEval/59", "prompt": "func largest_prime_factor:num n:num", "canonical_solution": "func is_prime:bool k:num\n    if k < 2\n        return false\n    end\n    for i := range 2 (k - 1)\n        if k % i == 0\n            return false\n        end\n    end\n    return true\nend\n\nlargest := 1\nfor j := range 2 (n + 1)\n    if n % j == 0 and is_prime j\n        largest = max largest j\n    end\nend\nreturn largest", "test": "func check\n    assert 5 (largest_prime_factor 15)\n    assert 3 (largest_prime_factor 27)\n    assert 7 (largest_prime_factor 63)\n    assert 11 (largest_prime_factor 330)\n    assert 29 (largest_prime_factor 13195)\nend", "entry_point": "largest_prime_factor"}
{"task_id": "HumanEval/60", "prompt": "func sum_to_n:num n:num", "canonical_solution": "sum := 0\nfor i := range 1 (n + 1)\n    sum = sum + i\nend\nreturn sum", "test": "func check\n    fails := 0\ntotal := 0\n\nfunc assert want:any got:any\ntotal = total + 1\nif want != got\nfails = fails + 1\nprintf \"want != got: want %v got %v\\n\" want got\nend\nend\n\nassert 1 (sum_to_n 1)\nassert 21 (sum_to_n 6)\nassert 66 (sum_to_n 11)\nassert 465 (sum_to_n 30)\nassert 5050 (sum_to_n 100)\n\nprintf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "sum_to_n"}
{"task_id": "HumanEval/62", "prompt": "func derivative:[]num xs:[]num", "canonical_solution": "res:[]num\nfor i := range (len xs)\n    if i > 0\n        res = res + [i * xs[i]]\n    end\nend\nreturn res", "test": "func check\ncandidate := derivative\nassert [1 4 12 20] (candidate [3 1 2 4 5])\nassert [2 6] (candidate [1 2 3])\nassert [2 2] (candidate [3 2 1])\nassert [2 2 0 16] (candidate [3 2 1 0 4])\nassert [] (candidate [1])\nend", "entry_point": "derivative"}
{"task_id": "HumanEval/65", "prompt": "func circular_shift:string x:num shift:num", "canonical_solution": "s:string\ns = sprintf \"%v\" x\nif shift > (len s)\n    return s[-1:0:-1]\nend\nreturn s[(len s) - shift:] + s[:(len s) - shift]", "test": "func check\n    assert \"001\" (circular_shift 100 2)\n    assert \"12\" (circular_shift 12 2)\n    assert \"79\" (circular_shift 97 8)\n    assert \"21\" (circular_shift 12 1)\n    assert \"11\" (circular_shift 11 101)\nend", "entry_point": "circular_shift"}
{"task_id": "HumanEval/56", "prompt": "func correct_bracketing:bool brackets:string", "canonical_solution": "depth := 0\nfor b := range brackets\n    if brackets[b] == \"<\"\n        depth = depth + 1\n    else\n        depth = depth - 1\n    end\n    if depth < 0\n        return false\n    end\nend\nreturn depth == 0", "test": "func check\n    assert true (correct_bracketing \"<>\")\n    assert true (correct_bracketing \"<<><>>\")\n    assert true (correct_bracketing \"<><><<><>><>\")\n    assert true (correct_bracketing \"<><><<<><><>><>><<><><<>>>\")\n    assert false (correct_bracketing \"<<<><>>>>\")\n    assert false (correct_bracketing \"><<>\")\n    assert false (correct_bracketing \"<\")\n    assert false (correct_bracketing \"<<<<\")\n    assert false (correct_bracketing \">\")\n    assert false (correct_bracketing \"<<>\")\n    assert false (correct_bracketing \"<><><<><>><>><<>\")\n    assert false (correct_bracketing \"<><><<><>><>>><>\")\nend", "entry_point": "correct_bracketing"}
{"task_id": "HumanEval/63", "prompt": "func fibfib:num n:num", "canonical_solution": "if n == 0\n    return 0\nend\nif n == 1\n    return 0\nend\nif n == 2\n    return 1\nend\nreturn fibfib (n - 1) + fibfib (n - 2) + fibfib (n - 3)\nend", "test": "func check\n    assert 1 (fibfib 2)\n    assert 0 (fibfib 1)\n    assert 4 (fibfib 5)\n    assert 24 (fibfib 8)\n    assert 81 (fibfib 10)\n    assert 274 (fibfib 12)\n    assert 927 (fibfib 14)\nend", "entry_point": "fibfib"}
{"task_id": "HumanEval/53", "prompt": "func add:num x:num y:num", "canonical_solution": "return x + y", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert 1 (add 0 1)\n    assert 1 (add 1 0)\n    assert 5 (add 2 3)\n    assert 12 (add 5 7)\n    assert 12 (add 7 5)\n\n    for i := range 100\n        x := rand 0 1000\n        y := rand 0 1000\n        assert (x + y) (add x y)\n    end\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "add"}
{"task_id": "HumanEval/61", "prompt": "func correct_bracketing:bool brackets:string", "canonical_solution": "depth := 0\nfor b := range brackets\n    if brackets[b] == \"(\"\n        depth = depth + 1\n    else\n        depth = depth - 1\n    end\n    if depth < 0\n        return false\n    end\nend\nreturn depth == 0", "test": "func check\n    assert (correct_bracketing \"()\")\n    assert (correct_bracketing \"(()())\")\n    assert (correct_bracketing \"()()(()())()\")\n    assert (correct_bracketing \"()()((()()())())(()()(()))\")\n    assert not (correct_bracketing \"((()())))\")\n    assert not (correct_bracketing \")(()\")\n    assert not (correct_bracketing \"(\")\n    assert not (correct_bracketing \"(((()\")\n    assert not (correct_bracketing \")\")\n    assert not (correct_bracketing \"(()\")\n    assert not (correct_bracketing \"()()(()())())(()\")\n    assert not (correct_bracketing \"()()(()())()))()\")\nend", "entry_point": "correct_bracketing"}
{"task_id": "HumanEval/58", "prompt": "func common:[]num l1:[]num l2:[]num", "canonical_solution": "ret:{}num\nfor e1 := range l1\n    for e2 := range l2\n        if l1[e1] == l2[e2]\n            ret[sprintf \"%v\" l1[e1]] = true\n        end\n    end\nend\nresult:[]num\nfor key := range ret\n    result = result + [atoi key]\nend\nreturn sort result", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n    assert [1 5 653] (common [1 4 3 34 653 2 5] [5 7 1 5 9 653 121])\n    assert [2 3] (common [5 3 2 8] [3 2])\n    assert [2 3 4] (common [4 3 2 8] [3 2 4])\n    assert [] (common [4 3 2 8] [])\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend\ncheck", "entry_point": "common"}
{"task_id": "HumanEval/57", "prompt": "func monotonic:bool l:[]num", "canonical_solution": "if l == (sort l) or l == (sort l true)\n    return true\nend\nreturn false", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n    assert true (monotonic [1 2 4 10])\n    assert true (monotonic [1 2 4 20])\n    assert false (monotonic [1 20 4 10])\n    assert true (monotonic [4 1 0 -10])\n    assert true (monotonic [4 1 1 0])\n    assert false (monotonic [1 2 3 2 5 60])\n    assert true (monotonic [1 2 3 4 5 60])\n    assert true (monotonic [9 9 9 9])\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "monotonic"}
{"task_id": "HumanEval/67", "prompt": "func fruit_distribution:s:string n:num", "canonical_solution": "lis:[]num\n    for i := range (split s ' ')\n        if (split s ' ')[i].(string).isdigit\n            lis = lis + [((split s ' ')[i]).(num)]\n        end\n    end\n    return n - (sum lis)", "test": "func check candidate:any\n    // Check some simple cases\n    assert 8 (candidate \"5 apples and 6 oranges\" 19)\n    assert 10 (candidate \"5 apples and 6 oranges\" 21)\n    assert 2 (candidate \"0 apples and 1 oranges\" 3)\n    assert 2 (candidate \"1 apples and 0 oranges\" 3)\n    assert 95 (candidate \"2 apples and 3 oranges\" 100)\n    assert 0 (candidate \"2 apples and 3 oranges\" 5)\n    assert 19 (candidate \"1 apples and 100 oranges\" 120)\nend", "entry_point": "fruit_distribution"}
{"task_id": "HumanEval/64", "prompt": "func vowels_count:num s:string", "canonical_solution": "vowels := \"aeiouAEIOU\"\n    n_vowels := 0\n    for c := range s\n        if contains vowels s[c]\n            n_vowels = n_vowels + 1\n        end\n    end\n    if s[-1] == 'y' or s[-1] == 'Y'\n        n_vowels = n_vowels + 1\n    end\n    return n_vowels", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"Test %v failed: expected %v, got %v\\n\" total want got\n        end\n    end\n\n    assert 2 (vowels_count \"abcde\")\n    assert 3 (vowels_count \"Alone\")\n    assert 2 (vowels_count \"key\")\n    assert 1 (vowels_count \"bye\")\n    assert 2 (vowels_count \"keY\")\n    assert 1 (vowels_count \"bYe\")\n    assert 3 (vowels_count \"ACEDY\")\n\n    if fails == 0\n        print \"All tests passed!\"\n    else\n        printf \"%v of %v tests failed.\\n\" fails total\n    end\nend", "entry_point": "vowels_count"}
{"task_id": "HumanEval/71", "prompt": "func triangle_area:num a:num b:num c:num", "canonical_solution": "if a + b <= c or a + c <= b or b + c <= a\n    return -1\nend\ns := (a + b + c) / 2\narea := (s * (s - a) * (s - b) * (s - c)) ** 0.5\narea = round area 2\nreturn area\nend", "test": "func check\n    assert 6.00 (triangle_area 3 4 5)\n    assert -1 (triangle_area 1 2 10)\n    assert 8.18 (triangle_area 4 8 5)\n    assert 1.73 (triangle_area 2 2 2)\n    assert -1 (triangle_area 1 2 3)\n    assert 16.25 (triangle_area 10 5 7)\n    assert -1 (triangle_area 2 6 3)\n    assert 0.43 (triangle_area 1 1 1)\n    assert -1 (triangle_area 2 2 10)\nend", "entry_point": "triangle_area"}
{"task_id": "HumanEval/68", "prompt": "func pluck:[]num arr:[]num", "canonical_solution": "if (len arr) == 0\n    return []\nend\nevens:[]num\nevens = filter (func x:num return x % 2 == 0 end) arr\nif evens == []\n    return []\nend\nreturn [min evens arr.index (min evens)]", "test": "func check candidate:any\n    assert [2 1] (candidate [4 2 3]) \"Error\"\n    assert [2 1] (candidate [1 2 3]) \"Error\"\n    assert [] (candidate []) \"Error\"\n    assert [0 1] (candidate [5 0 3 0 4 2]) \"Error\"\n    assert [0 3] (candidate [1 2 3 0 5 3]) \"Error\"\n    assert [4 1] (candidate [5 4 8 4 8]) \"Error\"\n    assert [6 1] (candidate [7 6 7 1]) \"Error\"\n    assert [] (candidate [7 9 7 1]) \"Error\"\nend", "entry_point": "pluck"}
{"task_id": "HumanEval/72", "prompt": "func will_it_fly:bool q:[]num w:num", "canonical_solution": "if (sum q) > w\n    return false\nend\ni := 0\nj := len q - 1\nwhile i < j\n    if q[i] != q[j]\n        return false\n    end\n    i = i + 1\n    j = j - 1\nend\nreturn true\nend", "test": "func check\n    fails := 0\ntotal := 0\nfunc assert want:any got:any\ntotal = total + 1\nif want != got\nfails = fails + 1\nprintf \"want != got: want %v got %v\\n\" want got\nend\nend\nassert true (will_it_fly [3 2 3] 9)\nassert false (will_it_fly [1 2] 5)\nassert true (will_it_fly [3] 5)\nassert false (will_it_fly [3 2 3] 1)\nassert false (will_it_fly [1 2 3] 6)\nassert true (will_it_fly [5] 5)\nprintf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "will_it_fly"}
{"task_id": "HumanEval/77", "prompt": "func iscube:bool a:num", "canonical_solution": "a = abs a\n    return (round (a ** (1.0 / 3.0))) ** 3 == a", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"Test error: want %v got %v\\n\" want got\n        end\n    end\n\n    assert true (candidate 1)\n    assert false (candidate 2)\n    assert true (candidate -1)\n    assert true (candidate 64)\n    assert false (candidate 180)\n    assert true (candidate 1000)\n    assert true (candidate 0)\n    assert false (candidate 1729)\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "iscube"}
{"task_id": "HumanEval/76", "prompt": "func is_simple_power:bool x:num n:num", "canonical_solution": "if n == 1\n    return x == 1\nend\npower := 1\nwhile power < x\n    power = power * n\nend\nreturn power == x", "test": "func check candidate:any\n    assert true (candidate 16 2)\n    assert false (candidate 143214 16)\n    assert true (candidate 4 2)\n    assert true (candidate 9 3)\n    assert true (candidate 16 4)\n    assert false (candidate 24 2)\n    assert false (candidate 128 4)\n    assert false (candidate 12 6)\n    assert true (candidate 1 1)\n    assert true (candidate 1 12)\nend", "entry_point": "is_simple_power"}
{"task_id": "HumanEval/73", "prompt": "func smallest_change:num arr:[]num", "canonical_solution": "ans := 0\n    for i := range (len arr) / 2\n        if arr[i] != arr[(len arr) - i - 1]\n            ans = ans + 1\n        end\n    end\n    return ans", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert 4 (smallest_change [1 2 3 5 4 7 9 6])\n    assert 1 (smallest_change [1 2 3 4 3 2 2])\n    assert 1 (smallest_change [1 4 2])\n    assert 1 (smallest_change [1 4 4 2])\n    assert 0 (smallest_change [1 2 3 2 1])\n    assert 0 (smallest_change [3 1 1 3])\n    assert 0 (smallest_change [1])\n    assert 1 (smallest_change [0 1])\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "smallest_change"}
{"task_id": "HumanEval/70", "prompt": "func strangeSortList:[]num lst:[]num", "canonical_solution": "res:[]num\nswitch:bool\nswitch = true\nwhile (len lst) > 0\n    if switch\n        minVal := min lst\n        res = res + [minVal]\n        lst = lst - [minVal]\n    else\n        maxVal := max lst\n        res = res + [maxVal]\n        lst = lst - [maxVal]\n    end\n    switch = !switch\nend\nreturn res", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n    assert [1 4 2 3] (strangeSortList [1 2 3 4])\n    assert [5 9 6 8 7] (strangeSortList [5 6 7 8 9])\n    assert [1 5 2 4 3] (strangeSortList [1 2 3 4 5])\n    assert [1 9 5 8 6 7] (strangeSortList [5 6 7 8 9 1])\n    assert [5 5 5 5] (strangeSortList [5 5 5 5])\n    assert [] (strangeSortList [])\n    assert [1 8 2 7 3 6 4 5] (strangeSortList [1 2 3 4 5 6 7 8])\n    assert [-5 5 -5 5 0 2 2 2] (strangeSortList [0 2 2 2 5 5 -5 -5])\n    assert [111111] (strangeSortList [111111])\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "strangeSortList"}
{"task_id": "HumanEval/79", "prompt": "func decimal_to_binary: string decimal: num", "canonical_solution": "return \"db\" + (sprintf \"%b\" decimal) + \"db\"", "test": "func check candidate:any\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n    assert \"db0db\" (candidate 0)\n    assert \"db100000db\" (candidate 32)\n    assert \"db1100111db\" (candidate 103)\n    assert \"db1111db\" (candidate 15)\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "decimal_to_binary"}
{"task_id": "HumanEval/78", "prompt": "func hex_key:num num:string", "canonical_solution": "primes := [\"2\" \"3\" \"5\" \"7\" \"B\" \"D\"]\n    total := 0\n    for i := range (len num)\n        if num[i] in primes\n            total = total + 1\n        end\n    end\n    return total", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"error: want %v got %v\\n\" want got\n        end\n    end\n\n    assert 1 (hex_key \"AB\")\n    assert 2 (hex_key \"1077E\")\n    assert 4 (hex_key \"ABED1A33\")\n    assert 2 (hex_key \"2020\")\n    assert 6 (hex_key \"123456789ABCDEF0\")\n    assert 12 (hex_key \"112233445566778899AABBCCDDEEFF00\")\n    assert 0 (hex_key \"\")\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "hex_key"}
{"task_id": "HumanEval/74", "prompt": "func total_match:[]string lst1:[]string lst2:[]string", "canonical_solution": "l1 := 0\n    for st := range lst1\n        l1 = l1 + (len st)\n    end\n    \n    l2 := 0\n    for st := range lst2\n        l2 = l2 + (len st)\n    end\n    \n    if l1 <= l2\n        return lst1\n    else\n        return lst2\n    end", "test": "func check candidate:any\n    // Check some simple cases\n    assert [] (candidate [] [])\n    assert [\"hi\" \"hi\"] (candidate [\"hi\" \"admin\"] [\"hi\" \"hi\"])\n    assert [\"hi\" \"admin\"] (candidate [\"hi\" \"admin\"] [\"hi\" \"hi\" \"admin\" \"project\"])\n    assert [\"4\"] (candidate [\"4\"] [\"1\" \"2\" \"3\" \"4\" \"5\"])\n    assert [\"hI\" \"Hi\"] (candidate [\"hi\" \"admin\"] [\"hI\" \"Hi\"])\n    assert [\"hI\" \"hi\" \"hi\"] (candidate [\"hi\" \"admin\"] [\"hI\" \"hi\" \"hi\"])\n    assert [\"hi\" \"admin\"] (candidate [\"hi\" \"admin\"] [\"hI\" \"hi\" \"hii\"])\n    // Check some edge cases that are easy to work out by hand.\n    assert [] (candidate [] [\"this\"])\n    assert [] (candidate [\"this\"] [])\nend", "entry_point": "total_match"}
{"task_id": "HumanEval/75", "prompt": "func is_multiply_prime:bool a:num", "canonical_solution": "func is_prime:bool n:num\n    for j := range 2 n\n        if n % j == 0\n            return false\n        end\n    end\n    return true\nend\n\nfor i := range 2 101\n    if not is_prime i\n        continue\n    end\n    for j := range 2 101\n        if not is_prime j\n            continue\n        end\n        for k := range 2 101\n            if not is_prime k\n                continue\n            end\n            if i * j * k == a\n                return true\n            end\n        end\n    end\nend\nreturn false", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert false (is_multiply_prime 5)\n    assert true (is_multiply_prime 30)\n    assert true (is_multiply_prime 8)\n    assert false (is_multiply_prime 10)\n    assert true (is_multiply_prime 125)\n    assert true (is_multiply_prime (3 * 5 * 7))\n    assert false (is_multiply_prime (3 * 6 * 7))\n    assert false (is_multiply_prime (9 * 9 * 9))\n    assert false (is_multiply_prime (11 * 9 * 9))\n    assert true (is_multiply_prime (11 * 13 * 7))\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "is_multiply_prime"}
{"task_id": "HumanEval/66", "prompt": "func digitSum:num s:string", "canonical_solution": "if s == \"\" return 0\nreturn sum [ord char if char.isupper else 0 for char := range s]", "test": "func check candidate:any\n    assert true \"This prints if this assert fails 1 (good for debugging!)\"\n    assert (candidate \"\") == 0 \"Error\"\n    assert (candidate \"abAB\") == 131 \"Error\"\n    assert (candidate \"abcCd\") == 67 \"Error\"\n    assert (candidate \"helloE\") == 69 \"Error\"\n    assert (candidate \"woArBld\") == 131 \"Error\"\n    assert (candidate \"aAaaaXa\") == 153 \"Error\"\n    assert true \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert (candidate \" How are yOu?\") == 151 \"Error\"\n    assert (candidate \"You arE Very Smart\") == 327 \"Error\"\nend", "entry_point": "digitSum"}
{"task_id": "HumanEval/84", "prompt": "func solve:string N:num", "canonical_solution": "return (bin (sum (int i for i := range (str N))))[2:]", "test": "func check\n    assert true \"This prints if this assert fails 1 (good for debugging!)\"\n    assert (solve 1000) == \"1\" \"Error\"\n    assert (solve 150) == \"110\" \"Error\"\n    assert (solve 147) == \"1100\" \"Error\"\n    assert true \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert (solve 333) == \"1001\" \"Error\"\n    assert (solve 963) == \"10010\" \"Error\"\nend", "entry_point": "solve"}
{"task_id": "HumanEval/80", "prompt": "func is_happy:bool s:string", "canonical_solution": "if (len s) < 3\n    return false\nend\nfor i := range 0 ((len s) - 2)\n    if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]\n        return false\n    end\nend\nreturn true\nend", "test": "func check candidate:any\n    assert false (candidate \"a\")\n    assert false (candidate \"aa\")\n    assert true (candidate \"abcd\")\n    assert false (candidate \"aabb\")\n    assert true (candidate \"adb\")\n    assert false (candidate \"xyy\")\n    assert true (candidate \"iopaxpoi\")\n    assert false (candidate \"iopaxioi\")\nend", "entry_point": "is_happy"}
{"task_id": "HumanEval/85", "prompt": "func add:num lst:[]num", "canonical_solution": "return sum [lst[i] for i := range 1 (len lst) 2 if lst[i] % 2 == 0]", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"Assertion failed: want %v got %v\\n\" want got\n        end\n    end\n    assert 88 (add [4 88])\n    assert 122 (add [4 5 6 7 2 122])\n    assert 0 (add [4 0 6 7])\n    assert 12 (add [4 4 6 8])\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "add"}
{"task_id": "HumanEval/83", "prompt": "func starts_one_ends:num n:num", "canonical_solution": "if n == 1\n    return 1\nend\nreturn 18 * (10 ** (n - 2))", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"This prints if this assert fails %v (good for debugging!)\\n\" fails\n        end\n    end\n    assert 1 (starts_one_ends 1)\n    assert 18 (starts_one_ends 2)\n    assert 180 (starts_one_ends 3)\n    assert 1800 (starts_one_ends 4)\n    assert 18000 (starts_one_ends 5)\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "starts_one_ends"}
{"task_id": "HumanEval/82", "prompt": "func prime_length:bool s:string", "canonical_solution": "l := len s\n    if l == 0 or l == 1\n        return false\n    end\n    for i := range 2 l\n        if l % i == 0\n            return false\n        end\n    end\n    return true", "test": "func check candidate:any\n    // Check some simple cases\n    assert true (candidate \"Hello\")\n    assert true (candidate \"abcdcba\")\n    assert true (candidate \"kittens\")\n    assert false (candidate \"orange\")\n    assert true (candidate \"wow\")\n    assert true (candidate \"world\")\n    assert true (candidate \"MadaM\")\n    assert true (candidate \"Wow\")\n    assert false (candidate \"\")\n    assert true (candidate \"HI\")\n    assert true (candidate \"go\")\n    assert false (candidate \"gogo\")\n    assert false (candidate \"aaaaaaaaaaaaaaa\")\n    // Check some edge cases that are easy to work out by hand.\n    assert true (candidate \"Madam\")\n    assert false (candidate \"M\")\n    assert false (candidate \"0\")\nend", "entry_point": "prime_length"}
{"task_id": "HumanEval/86", "prompt": "func anti_shuffle:string s:string", "canonical_solution": "return (join \" \" [(join \"\" (sort (list i))) for i := range (split s \" \")])", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n    assert \"Hi\" (anti_shuffle \"Hi\")\n    assert \"ehllo\" (anti_shuffle \"hello\")\n    assert \"bemnru\" (anti_shuffle \"number\")\n    assert \"abcd\" (anti_shuffle \"abcd\")\n    assert \"Hello !!!Wdlor\" (anti_shuffle \"Hello World!!!\")\n    assert \"\" (anti_shuffle \"\")\n    assert \".Hi My aemn is Meirst .Rboot How aer ?ouy\" (anti_shuffle \"Hi. My name is Mister Robot. How are you?\")\n    assert true\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "anti_shuffle"}
{"task_id": "HumanEval/88", "prompt": "func sortArray:[]num array:[]num", "canonical_solution": "sortedArray:[]num\nsortedArray = array\nif (len array) == 0\n    return []\nend\nif (array[0] + array[-1]) % 2 == 0\n    sortedArray = sorted array reverse:true\nelse\n    sortedArray = sorted array\nend\nreturn sortedArray", "test": "func check\n    fails := 0\ntotal := 0\n\nfunc assert want:any got:any\n    total = total + 1\n    if want != got\n        fails = fails + 1\n        printf \"want != got: want %v got %v\\n\" want got\n    end\nend\n\n// -- Test Cases Start -- //\nassert [] (sortArray [])\nassert [5] (sortArray [5])\nassert [0 1 2 3 4 5] (sortArray [2 4 3 0 1 5])\nassert [6 5 4 3 2 1 0] (sortArray [2 4 3 0 1 5 6])\nassert [1 2] (sortArray [2 1])\nassert [0 11 15 32 42 87] (sortArray [15 42 87 32 11 0])\nassert [23 21 14 11] (sortArray [21 14 23 11])\n// -- Test Cases End -- //\nprintf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "sortArray"}
{"task_id": "HumanEval/90", "prompt": "func next_smallest:any lst:[]num", "canonical_solution": "lst = unique sort lst\n    if len lst < 2\n        return false\n    end\n    return lst[1]\nend", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert 2 (next_smallest [1 2 3 4 5])\n    assert 2 (next_smallest [5 1 4 3 2])\n    assert false (next_smallest [])\n    assert false (next_smallest [1 1])\n    assert 1 (next_smallest [1 1 1 1 0])\n    assert false (next_smallest [1 0**0])\n    assert -35 (next_smallest [-35 34 12 -45])\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "next_smallest"}
{"task_id": "HumanEval/93", "prompt": "func encode:string message:string", "canonical_solution": "vowels := \"aeiouAEIOU\"\nvowels_replace:{}string\nfor i := range vowels\n    vowels_replace[vowels[i]] = sprintf \"%c\" (ord vowels[i] + 2)\nend\nmessage = swapcase message\nresult := \"\"\nfor i := range message\n    if has vowels_replace message[i]\n        result = result + vowels_replace[message[i]]\n    else\n        result = result + message[i]\n    end\nend\nreturn result", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"This prints if this assert fails %v (good for debugging!)\\n\" (total - fails)\n        end\n    end\n    assert \"tgst\" (encode \"TEST\")\n    assert \"mWDCSKR\" (encode \"Mudasir\")\n    assert \"ygs\" (encode \"YES\")\n    assert \"tHKS KS C MGSSCGG\" (encode \"This is a message\")\n    assert \"k dQnT kNqW wHcT Tq wRkTg\" (encode \"I DoNt KnOw WhAt tO WrItE\")\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "encode"}
{"task_id": "HumanEval/87", "prompt": "func get_row:[]any lst:[][]any x:any", "canonical_solution": "coords:[]any\n    for i := range (len lst)\n        for j := range (len lst[i])\n            if lst[i][j] == x\n                coords = coords + [[i j]]\n            end\n        end\n    end\n    coords = sort coords by [0] then by [1] desc\n    return coords", "test": "func check candidate:any\n    assert [[0 0] [1 4] [1 0] [2 5] [2 0]] (candidate [[1 2 3 4 5 6] [1 2 3 4 1 6] [1 2 3 4 5 1]] 1)\n    assert [[0 1] [1 1] [2 1] [3 1] [4 1] [5 1]] (candidate [[1 2 3 4 5 6] [1 2 3 4 5 6] [1 2 3 4 5 6] [1 2 3 4 5 6] [1 2 3 4 5 6] [1 2 3 4 5 6]] 2)\n    assert [[0 0] [1 0] [2 1] [2 0] [3 2] [3 0] [4 3] [4 0] [5 4] [5 0] [6 5] [6 0]] (candidate [[1 2 3 4 5 6] [1 2 3 4 5 6] [1 1 3 4 5 6] [1 2 1 4 5 6] [1 2 3 1 5 6] [1 2 3 4 1 6] [1 2 3 4 5 1]] 1)\n    assert [] (candidate [] 1)\n    assert [] (candidate [[1]] 2)\n    assert [[2 2]] (candidate [[[] [1] [1 2 3]]] 3)\nend", "entry_point": "get_row"}
{"task_id": "HumanEval/81", "prompt": "func numerical_letter_grade:[]string grades:[]num", "canonical_solution": "letter_grade:[]string\n    for gpa := range grades\n        if gpa == 4.0\n            letter_grade = letter_grade + [\"A+\"]\n        else if gpa > 3.7\n            letter_grade = letter_grade + [\"A\"]\n        else if gpa > 3.3\n            letter_grade = letter_grade + [\"A-\"]\n        else if gpa > 3.0\n            letter_grade = letter_grade + [\"B+\"]\n        else if gpa > 2.7\n            letter_grade = letter_grade + [\"B\"]\n        else if gpa > 2.3\n            letter_grade = letter_grade + [\"B-\"]\n        else if gpa > 2.0\n            letter_grade = letter_grade + [\"C+\"]\n        else if gpa > 1.7\n            letter_grade = letter_grade + [\"C\"]\n        else if gpa > 1.3\n            letter_grade = letter_grade + [\"C-\"]\n        else if gpa > 1.0\n            letter_grade = letter_grade + [\"D+\"]\n        else if gpa > 0.7\n            letter_grade = letter_grade + [\"D\"]\n        else if gpa > 0.0\n            letter_grade = letter_grade + [\"D-\"]\n        else\n            letter_grade = letter_grade + [\"E\"]\n    end\n    return letter_grade", "test": "func check candidate:any\n    assert [\"A+\", \"B\", \"C-\", \"C\", \"A-\"] (candidate [4.0 3 1.7 2 3.5])\n    assert [\"D+\"] (candidate [1.2])\n    assert [\"D-\"] (candidate [0.5])\n    assert [\"E\"] (candidate [0.0])\n    assert [\"D\", \"D-\", \"C-\", \"B\", \"B+\"] (candidate [1 0.3 1.5 2.8 3.3])\n    assert [\"E\", \"D-\"] (candidate [0 0.7])\nend", "entry_point": "numerical_letter_grade"}
{"task_id": "HumanEval/91", "prompt": "func is_bored:string S:string", "canonical_solution": "sentences:[]string\n    sentences = split S r'[.?!]\\s*'\n    boredom_count := 0\n    for sentence := range sentences\n        if startswith sentences[sentence] \"I \"\n            boredom_count = boredom_count + 1\n        end\n    end\n    return sprintf \"%v\" boredom_count", "test": "func check candidate:any\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"Test %v failed: want %v got %v\\n\" total want got\n        end\n    end\n    assert \"0\" (candidate \"Hello world\")\n    assert \"0\" (candidate \"Is the sky blue?\")\n    assert \"1\" (candidate \"I love It !\")\n    assert \"0\" (candidate \"bIt\")\n    assert \"2\" (candidate \"I feel good today. I will be productive. will kill It\")\n    assert \"0\" (candidate \"You and I are going for a walk\")\n    if fails == 0\n        print \"All tests passed.\"\n    else\n        printf \"%v of %v tests failed.\"\n    end\nend", "entry_point": "is_bored"}
{"task_id": "HumanEval/96", "prompt": "func count_up_to:[]num n:num", "canonical_solution": "primes:[]num\n    for i := range 2 n\n        is_prime := true\n        for j := range 2 i\n            if i % j == 0\n                is_prime = false\n                break\n            end\n        end\n        if is_prime\n            primes = primes + [i]\n        end\n    end\n    return primes", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert [2 3] (candidate 5)\n    assert [2 3 5] (candidate 6)\n    assert [2 3 5] (candidate 7)\n    assert [2 3 5 7] (candidate 10)\n    assert [] (candidate 0)\n    assert [2 3 5 7 11 13 17 19] (candidate 22)\n    assert [] (candidate 1)\n    assert [2 3 5 7 11 13 17] (candidate 18)\n    assert [2 3 5 7 11 13 17 19 23 29 31 37 41 43] (candidate 47)\n    assert [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97] (candidate 101)\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "count_up_to"}
{"task_id": "HumanEval/92", "prompt": "func any_int:bool x:any y:any z:any", "canonical_solution": "if typeof x == \"num\" and typeof y == \"num\" and typeof z == \"num\" and x == floor x and y == floor y and z == floor z\n    if (x + y == z) or (x + z == y) or (y + z == x)\n        return true\n    end\n    return false\nend\nreturn false\nend", "test": "func check candidate:any\n    assert true (candidate 2 3 1)\n    assert false (candidate 2.5 2 3)\n    assert false (candidate 1.5 5 3.5)\n    assert false (candidate 2 6 2)\n    assert true (candidate 4 2 2)\n    assert false (candidate 2.2 2.2 2.2)\n    assert true (candidate -4 6 2)\n    assert true (candidate 2 1 1)\n    assert true (candidate 3 4 7)\n    assert false (candidate 3.0 4 7)\nend\ncheck any_int", "entry_point": "any_int"}
{"task_id": "HumanEval/97", "prompt": "func multiply:num a:num b:num", "canonical_solution": "return abs a % 10 * abs b % 10", "test": "func check\ncandidate:any\n\n// Check some simple cases\nassert 16 (candidate 148 412) // \"First test error: \" + (candidate 148 412)\nassert 72 (candidate 19 28) // \"Second test error: \" + (candidate 19 28)\nassert 0 (candidate 2020 1851) // \"Third test error: \" + (candidate 2020 1851)\nassert 20 (candidate 14 -15) // \"Fourth test error: \" + (candidate 14 -15)\nassert 42 (candidate 76 67) // \"Fifth test error: \" + (candidate 76 67)\nassert 49 (candidate 17 27) // \"Sixth test error: \" + (candidate 17 27)\n\n// Check some edge cases that are easy to work out by hand.\nassert 0 (candidate 0 1) // \"1st edge test error: \" + (candidate 0 1)\nassert 0 (candidate 0 0) // \"2nd edge test error: \" + (candidate 0 0)\nend", "entry_point": "multiply"}
{"task_id": "HumanEval/98", "prompt": "func count_upper:num s:string", "canonical_solution": "count := 0\nfor i := range 0 (len s) 2\n    if \"AEIOU\".contains s[i]\n        count = count + 1\n    end\nend\nreturn count", "test": "func check candidate:any\n    fails := 0\ntotal := 0\nfunc assert want:any got:any\ntotal = total + 1\nif want != got\nfails = fails + 1\nprintf \"want != got: want %v got %v\\n\" want got\nend\nend\nassert 1 (candidate \"aBCdEf\")\nassert 0 (candidate \"abcdefg\")\nassert 0 (candidate \"dBBE\")\nassert 0 (candidate \"B\")\nassert 1 (candidate \"U\")\nassert 0 (candidate \"\")\nassert 2 (candidate \"EEEE\")\nprintf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "count_upper"}
{"task_id": "HumanEval/94", "prompt": "func largestPrimeSum: num lst: []num", "canonical_solution": "func isPrime: bool n: num\n    for i := range 2 (int (n ** 0.5) + 1)\n        if n % i == 0\n            return false\n        end\n    end\n    return true\nend\n\nmaxx := 0\ni := 0\nwhile i < len lst\n    if lst[i] > maxx and isPrime lst[i]\n        maxx = lst[i]\n    end\n    i = i + 1\nend\nresult := 0\nfor digit := range (sprintf \"%v\" maxx)\n    result = result + int digit\nend\nreturn result", "test": "func check candidate: func\n    assert 10 (candidate [0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3])\n    assert 25 (candidate [1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1])\n    assert 13 (candidate [1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3])\n    assert 11 (candidate [0 724 32 71 99 32 6 0 5 91 83 0 5 6])\n    assert 3 (candidate [0 81 12 3 1 21])\n    assert 7 (candidate [0 8 1 2 1 7])\n    assert 19 (candidate [8191])\n    assert 19 (candidate [8191 123456 127 7])\n    assert 10 (candidate [127 97 8192])\nend", "entry_point": "largestPrimeSum"}
{"task_id": "HumanEval/89", "prompt": "func encrypt:string s:string", "canonical_solution": "d := \"abcdefghijklmnopqrstuvwxyz\"\nout := \"\"\nfor c := range s\n    if indexof d s[c] != -1\n        out = out + d[(indexof d s[c]+2*2) % 26]\n    else\n        out = out + s[c]\n    end\nend\nreturn out", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"This prints if this assert fails %v (good for debugging!)\\n\" want got\n        end\n    end\n    assert \"lm\" (encrypt \"hi\")\n    assert \"ewhjklnop\" (encrypt \"asdfghjkl\")\n    assert \"kj\" (encrypt \"gf\")\n    assert \"ix\" (encrypt \"et\")\n    assert \"jeiajeaijeiak\" (encrypt \"faewfawefaewg\")\n    assert \"lippsqcjvmirh\" (encrypt \"hellomyfriend\")\n    assert \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" (encrypt \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")\n    assert \"e\" (encrypt \"a\")\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "encrypt"}
{"task_id": "HumanEval/100", "prompt": "func make_a_pile:[]num n:num", "canonical_solution": "return [n + 2*i for i := range n]", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"Test failed: want %v got %v\\n\" want got\n        end\n    end\n    assert [3 5 7] (make_a_pile 3)\n    assert [4 6 8 10] (make_a_pile 4)\n    assert [5 7 9 11 13] (make_a_pile 5)\n    assert [6 8 10 12 14 16] (make_a_pile 6)\n    assert [8 10 12 14 16 18 20 22] (make_a_pile 8)\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "make_a_pile"}
{"task_id": "HumanEval/95", "prompt": "func check_dict_case:bool dict:{}any", "canonical_solution": "if len dict == 0\n    return false\nend\nstate := \"start\"\nfor key := range dict\n    if typeof key != \"string\"\n        state = \"mixed\"\n        break\n    end\n    if state == \"start\"\n        if key == (key.toUpper key)\n            state = \"upper\"\n        else if key == (key.toLower key)\n            state = \"lower\"\n        else\n            break\n        end\n    else if (state == \"upper\" and key != (key.toUpper key)) or (state == \"lower\" and key != (key.toLower key))\n        state = \"mixed\"\n        break\n    end\nend\nreturn state == \"upper\" or state == \"lower\"", "test": "func check\ncandidate := check_dict_case\n// Check some simple cases\nassert true (candidate {\"p\":\"pineapple\" \"b\":\"banana\"})\nassert false (candidate {\"p\":\"pineapple\" \"A\":\"banana\" \"B\":\"banana\"})\nassert false (candidate {\"p\":\"pineapple\" 5:\"banana\" \"a\":\"apple\"})\nassert false (candidate {\"Name\":\"John\" \"Age\":\"36\" \"City\":\"Houston\"})\nassert true (candidate {\"STATE\":\"NC\" \"ZIP\":\"12345\" })\nassert true (candidate {\"fruit\":\"Orange\" \"taste\":\"Sweet\" })\n// Check some edge cases that are easy to work out by hand.\nassert false (candidate {})\nend", "entry_point": "check_dict_case"}
{"task_id": "HumanEval/101", "prompt": "func wordsString:[]string s:string", "canonical_solution": "sList:[]string\n\nfor letter := range s\n    if letter == ','\n        sList = sList + [' ']\n    else\n        sList = sList + [letter]\n    end\nend\n\nsList = join sList \"\"\nsList = split sList \" \"\n\nreturn sList", "test": "func check candidate:any\n\n    assert [] (candidate \"\")\n    assert [\"Hi\" \"my\" \"name\" \"is\" \"John\"] (candidate \"Hi, my name is John\")\n    assert [\"One\" \"two\" \"three\" \"four\" \"five\" \"six\"] (candidate \"One, two, three, four, five, six\")\n    assert [\"Hi\" \"my\" \"name\"] (candidate \"Hi, my name\")\n    assert [\"One\" \"two\" \"three\" \"four\" \"five\" \"six\"] (candidate \"One,, two, three, four, five, six,\")\n    assert [\"ahmed\" \"gamal\"] (candidate \"ahmed     , gamal\")\nend", "entry_point": "wordsString"}
{"task_id": "HumanEval/102", "prompt": "func choose_num:num x:num y:num", "canonical_solution": "if x > y\n    return -1\nend\nif y % 2 == 0\n    return y\nend\nif x == y\n    return -1\nend\nreturn y - 1\nend", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n    assert 14 (choose_num 12 15)\n    assert -1 (choose_num 13 12)\n    assert 12354 (choose_num 33 12354)\n    assert -1 (choose_num 5234 5233)\n    assert 28 (choose_num 6 29)\n    assert -1 (choose_num 27 10)\n    assert -1 (choose_num 7 7)\n    assert 546 (choose_num 546 546)\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "choose_num"}
{"task_id": "HumanEval/109", "prompt": "func move_one_ball:bool arr:[]num", "canonical_solution": "if len arr == 0\n    return true\nend\nsorted_array := sort arr\nmin_value := min arr\nmin_index := index arr min_value\nmy_arr := arr[min_index:] + arr[:min_index]\nfor i := range (len arr)\n    if my_arr[i] != sorted_array[i]\n        return false\n    end\nend\nreturn true", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"This prints if this assert fails: want %v got %v\\n\" want got\n        end\n    end\n    assert true (move_one_ball [3 4 5 1 2])\n    assert true (move_one_ball [3 5 10 1 2])\n    assert false (move_one_ball [4 3 1 2])\n    assert false (move_one_ball [3 5 4 1 2])\n    assert true (move_one_ball [])\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "move_one_ball"}
{"task_id": "HumanEval/99", "prompt": "func closestInteger:num value:string", "canonical_solution": "from math import floor, ceil\n\nif value.count('.') == 1:\n    // remove trailing zeros\n    while (value[-1] == '0'):\n        value = value[:-1]\n\nnum = float(value)\nif value[-2:] == '.5':\n    if num > 0:\n        res = ceil(num)\n    else:\n        res = floor(num)\nelif len(value) > 0:\n    res = int(round(num))\nelse:\n    res = 0\n\nreturn res", "test": "func check\n    // Check some simple cases\n    assert 10 (closestInteger \"10\")\n    assert 15 (closestInteger \"14.5\")\n    assert -16 (closestInteger \"-15.5\")\n    assert 15 (closestInteger \"15.3\")\n\n    // Check some edge cases that are easy to work out by hand.\n    assert 0 (closestInteger \"0\")\nend", "entry_point": "closestInteger"}
{"task_id": "HumanEval/107", "prompt": "func even_odd_palindrome:[]num n:num", "canonical_solution": "even := 0\n    odd := 0\n    for i := range 1 (n + 1)\n        if (sprintf \"%v\" i) == (reverse (sprintf \"%v\" i))\n            if i % 2 == 0\n                even = even + 1\n            else\n                odd = odd + 1\n            end\n        end\n    end\n    return [even odd]", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    func finished\n        printf \"%v of %v tests passed\\n\" (total - fails) total\n    end\n\n    assert [8 13] (candidate 123)\n    assert [4 6] (candidate 12)\n    assert [1 2] (candidate 3)\n    assert [6 8] (candidate 63)\n    assert [5 6] (candidate 25)\n    assert [4 6] (candidate 19)\n    assert [4 5] (candidate 9)\n    assert [0 1] (candidate 1)\n\n    finished\nend", "entry_point": "even_odd_palindrome"}
{"task_id": "HumanEval/106", "prompt": "func f:[]num n:num", "canonical_solution": "ret:[]num\n    for i := range 1 (n + 1)\n        if i % 2 == 0\n            x := 1\n            for j := range 1 (i + 1)\n                x = x * j\n            end\n            ret = ret + [x]\n        else\n            x := 0\n            for j := range 1 (i + 1)\n                x = x + j\n            end\n            ret = ret + [x]\n        end\n    end\n    return ret", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert [1 2 6 24 15] (candidate 5)\n    assert [1 2 6 24 15 720 28] (candidate 7)\n    assert [1] (candidate 1)\n    assert [1 2 6] (candidate 3)\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "f"}
{"task_id": "HumanEval/110", "prompt": "func exchange: string lst1: []num lst2: []num", "canonical_solution": "odd := 0\neven := 0\nfor i := range lst1\n    if lst1[i] % 2 == 1\n        odd = odd + 1\n    end\nend\nfor i := range lst2\n    if lst2[i] % 2 == 0\n        even = even + 1\n    end\nend\nif even >= odd\n    return \"YES\"\nend\nreturn \"NO\"", "test": "func check candidate:any\n    assert \"YES\" (candidate [1 2 3 4] [1 2 3 4])\n    assert \"NO\" (candidate [1 2 3 4] [1 5 3 4])\n    assert \"YES\" (candidate [1 2 3 4] [2 1 4 3])\n    assert \"YES\" (candidate [5 7 3] [2 6 4])\n    assert \"NO\" (candidate [5 7 3] [2 6 3])\n    assert \"NO\" (candidate [3 2 6 1 8 9] [3 5 5 1 1 1])\n    assert \"YES\" (candidate [100 200] [200 200])\nend", "entry_point": "exchange"}
{"task_id": "HumanEval/112", "prompt": "func reverse_delete:s c:string", "canonical_solution": "s = join [char for char := range s if not contains c char]\nreturn (s s == reverse s)", "test": "func check candidate:any\n    assert (\"bcd\" false) == candidate \"abcde\" \"ae\"\n    assert (\"acdef\" false) == candidate \"abcdef\" \"b\"\n    assert (\"cdedc\" true) == candidate \"abcdedcba\" \"ab\"\n    assert (\"dik\" false) == candidate \"dwik\" \"w\"\n    assert (\"\" true) == candidate \"a\" \"a\"\n    assert (\"abcdedcba\" true) == candidate \"abcdedcba\" \"\"\n    assert (\"abcdedcba\" true) == candidate \"abcdedcba\" \"v\"\n    assert (\"abba\" true) == candidate \"vabba\" \"v\"\n    assert (\"\" true) == candidate \"mamma\" \"mia\"\nend", "entry_point": "reverse_delete"}
{"task_id": "HumanEval/108", "prompt": "func count_nums: num arr: []num", "canonical_solution": "func digits_sum:num n:num\n    neg := 1\n    if n < 0\n        n = -1 * n\n        neg = -1\n    end\n    n_str := sprintf \"%v\" n\n    n_arr := []\n    for i := range (len n_str)\n        n_arr = n_arr + [strtonum n_str[i]]\n    end\n    n_arr[0] = n_arr[0] * neg\n    sum := 0\n    for i := range n_arr\n        sum = sum + n_arr[i]\n    end\n    return sum\nend\n\nres := []\nfor i := range arr\n    res = res + [digits_sum arr[i]]\nend\n\npositive_count := 0\nfor i := range res\n    if res[i] > 0\n        positive_count = positive_count + 1\n    end\nend\nreturn positive_count", "test": "func check\n    assert 0 (count_nums [])\n    assert 0 (count_nums [-1 -2 0])\n    assert 6 (count_nums [1 1 2 -2 3 4 5])\n    assert 5 (count_nums [1 6 9 -6 0 1 5])\n    assert 4 (count_nums [1 100 98 -7 1 -1])\n    assert 5 (count_nums [12 23 34 -45 -56 0])\n    assert 1 (count_nums [-0 1])\n    assert 1 (count_nums [1])\nend", "entry_point": "count_nums"}
{"task_id": "HumanEval/113", "prompt": "func odd_count:[]string lst:[]string", "canonical_solution": "res:[]string\n    for arr := range lst\n        n:num\n        n = 0\n        for d := range arr\n            if (num(arr[d]) % 2) == 1\n                n = n + 1\n            end\n        end\n        res = res + [\"the number of odd elements \" + (sprintf \"%v\" n) + \"n the str\"+ (sprintf \"%v\" n) +\"ng \"+ (sprintf \"%v\" n) +\" of the \"+ (sprintf \"%v\" n) +\"nput.\"]\n    end\n    return res", "test": "func check candidate:any\n    assert [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"] (candidate [\"1234567\"])\n    assert [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"] (candidate [\"3\",\"11111111\"])\n    assert ['the number of odd elements 2n the str2ng 2 of the 2nput.', 'the number of odd elements 3n the str3ng 3 of the 3nput.', 'the number of odd elements 2n the str2ng 2 of the 2nput.'] (candidate ['271', '137', '314'])\nend\ncheck odd_count", "entry_point": "odd_count"}
{"task_id": "HumanEval/104", "prompt": "func uniqueDigits:[]num x:[]num", "canonical_solution": "oddDigitElements:[]num\n    for i := range x\n        allOdd := true\n        for c := range (sprintf \"%v\" x[i])\n            if (c.(string)[0] - '0') % 2 == 0\n                allOdd = false\n                break\n            end\n        end\n        if allOdd\n            oddDigitElements = oddDigitElements + [x[i]]\n        end\n    end\n    sort oddDigitElements\n    return oddDigitElements", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert [1 15 33] (uniqueDigits [15 33 1422 1])\n    assert [] (uniqueDigits [152 323 1422 10])\n    assert [111 151] (uniqueDigits [12345 2033 111 151])\n    assert [31 135] (uniqueDigits [135 103 31])\n\n    if fails == 0\n        print \"All tests passed!\"\n    else\n        printf \"%v of %v tests passed\\n\" (total - fails) total\n    end\nend", "entry_point": "uniqueDigits"}
{"task_id": "HumanEval/117", "prompt": "func select_words:[]string s:string n:num", "canonical_solution": "result:[]string\n    for word := range (split s \" \")\n        n_consonants := 0\n        for i := range (len word)\n            if !(contains \"aeiou\" (word[i].(string).lower))\n                n_consonants = n_consonants + 1\n            end\n        end\n        if n_consonants == n\n            result = result + [word]\n        end\n    end\n    return result", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"error: want %v got %v\\n\" want got\n        end\n    end\n\n    assert [\"little\"] (candidate \"Mary had a little lamb\" 4)\n    assert [\"Mary\" \"lamb\"] (candidate \"Mary had a little lamb\" 3)\n    assert [] (candidate \"simple white space\" 2)\n    assert [\"world\"] (candidate \"Hello world\" 4)\n    assert [\"Uncle\"] (candidate \"Uncle sam\" 3)\n    assert [] (candidate \"\" 4)\n    assert [\"b\" \"c\" \"d\" \"f\"] (candidate \"a b c d e f\" 1)\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "select_words"}
{"task_id": "HumanEval/114", "prompt": "func minSubArraySum:num nums:[]num", "canonical_solution": "max_sum := 0\ns := 0\nfor num := range nums\n    s = s + -num\n    if s < 0\n        s = 0\n    end\n    max_sum = max s max_sum\nend\nif max_sum == 0\n    max_sum = max [-i for i := range nums]\nend\nmin_sum := -max_sum\nreturn min_sum", "test": "func check\n    assert 1 (minSubArraySum [2 3 4 1 2 4])\n    assert -6 (minSubArraySum [-1 -2 -3])\n    assert -14 (minSubArraySum [-1 -2 -3 2 -10])\n    assert -9999999999999999 (minSubArraySum [-9999999999999999])\n    assert 0 (minSubArraySum [0 10 20 1000000])\n    assert -6 (minSubArraySum [-1 -2 -3 10 -5])\n    assert -6 (minSubArraySum [100 -1 -2 -3 10 -5])\n    assert 3 (minSubArraySum [10 11 13 8 3 4])\n    assert -33 (minSubArraySum [100 -33 32 -1 0 -2])\n    assert -10 (minSubArraySum [-10])\n    assert 7 (minSubArraySum [7])\n    assert -1 (minSubArraySum [1 -1])\nend", "entry_point": "minSubArraySum"}
{"task_id": "HumanEval/121", "prompt": "func solution:num lst:[]num", "canonical_solution": "return sum [x for idx := range (len lst) if idx % 2 == 0 and lst[idx] % 2 == 1]", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n    assert 12 (solution [5 8 7 1])\n    assert 9 (solution [3 3 3 3 3])\n    assert 0 (solution [30 13 24 321])\n    assert 5 (solution [5 9])\n    assert 0 (solution [2 4 8])\n    assert 23 (solution [30 13 23 32])\n    assert 3 (solution [3 13 2 9])\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "solution"}
{"task_id": "HumanEval/105", "prompt": "func by_length:[]string arr:[]num", "canonical_solution": "dic:{}string\n    dic[1] = \"One\"\n    dic[2] = \"Two\"\n    dic[3] = \"Three\"\n    dic[4] = \"Four\"\n    dic[5] = \"Five\"\n    dic[6] = \"Six\"\n    dic[7] = \"Seven\"\n    dic[8] = \"Eight\"\n    dic[9] = \"Nine\"\n    sorted_arr:[]num\n    sorted_arr = arr\n    sort sorted_arr reverse:true\n    new_arr:[]string\n    for var := range sorted_arr\n        if var >= 1 and var <= 9\n            new_arr = new_arr + [dic[var]]\n        end\n    end\n    return new_arr", "test": "func check candidate:any\n    assert true \"This prints if this assert fails 1 (good for debugging!)\"\n    assert [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"] (candidate [2 1 1 4 5 8 2 3]) \"Error\"\n    assert [] (candidate []) \"Error\"\n    assert [\"One\"] (candidate [1 -1 55]) \"Error\"\n    assert true \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert [\"Three\", \"Two\", \"One\"] (candidate [1 -1 3 2])\n    assert [\"Nine\", \"Eight\", \"Four\"] (candidate [9 4 8])\nend", "entry_point": "by_length"}
{"task_id": "HumanEval/118", "prompt": "func get_closest_vowel:string word:string", "canonical_solution": "vowels:{}string\nvowels = {\"a\":true \"e\":true \"i\":true \"o\":true \"u\":true \"A\":true \"E\":true \"I\":true \"O\":true \"U\":true}\nfor i := range (len word) - 2 0 -1\n    if has vowels word[i]\n        if not (has vowels word[i+1]) and not (has vowels word[i-1])\n            return word[i]\n        end\n    end\nend\nreturn \"\"", "test": "func check candidate:any\n    assert \"u\" (candidate \"yogurt\")\n    assert \"u\" (candidate \"full\")\n    assert \"\" (candidate \"easy\")\n    assert \"\" (candidate \"eAsy\")\n    assert \"\" (candidate \"ali\")\n    assert \"a\" (candidate \"bad\")\n    assert \"o\" (candidate \"most\")\n    assert \"\" (candidate \"ab\")\n    assert \"\" (candidate \"ba\")\n    assert \"\" (candidate \"quick\")\n    assert \"i\" (candidate \"anime\")\n    assert \"\" (candidate \"Asia\")\n    assert \"o\" (candidate \"Above\")\nend\ncheck get_closest_vowel", "entry_point": "get_closest_vowel"}
{"task_id": "HumanEval/111", "prompt": "func histogram:{}string test:string", "canonical_solution": "dict1:{}num\n    list1:[]string\n    list1 = test.split(\" \")\n    t:num\n    t = 0\n\n    for i := range (len list1)\n        if (count list1 list1[i] > t) and list1[i] != ''\n            t = count list1 list1[i]\n        end\n    end\n    if t > 0\n        for i := range (len list1)\n            if (count list1 list1[i] == t)\n                dict1[list1[i]] = t\n            end\n        end\n    end\n    return dict1", "test": "func check candidate:any\n\n    // Check some simple cases\n    assert {\"a\":2,\"b\": 2} (candidate 'a b b a')\n    assert {\"a\": 2, \"b\": 2} (candidate 'a b c a b')\n    assert {\"a\": 1, \"b\": 1, \"c\": 1, \"d\": 1, \"g\": 1} (candidate 'a b c d g')\n    assert {\"r\": 1,\"t\": 1,\"g\": 1} (candidate 'r t g')\n    assert {\"b\": 4} (candidate 'b b b b a')\n    assert {\"r\": 1,\"t\": 1,\"g\": 1} (candidate 'r t g')\n    \n    // Check some edge cases that are easy to work out by hand.\n    assert {} (candidate '')\n    assert {\"a\": 1} (candidate 'a')\nend", "entry_point": "histogram"}
{"task_id": "HumanEval/116", "prompt": "func sortArray:[]num arr:[]num", "canonical_solution": "arr = arr | sort | sortby (lambda x:num -> num bin x | count \"1\")\nreturn arr", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"Assertion failed: want %v got %v\\n\" want got\n        end\n    end\n    assert [1 2 4 3 5] (sortArray [1 5 2 3 4])\n    assert [-4 -2 -6 -5 -3] (sortArray [-2 -3 -4 -5 -6])\n    assert [0 1 2 4 3] (sortArray [1 0 2 3 4])\n    assert [] (sortArray [])\n    assert [2 2 4 4 3 3 5 5 5 7 77] (sortArray [2 5 77 4 5 3 5 7 2 3 4])\n    assert [32 3 5 6 12 44] (sortArray [3 6 44 12 32 5])\n    assert [2 4 8 16 32] (sortArray [2 4 8 16 32])\n    assert [2 4 8 16 32] (sortArray [2 4 8 16 32])\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "sortArray"}
{"task_id": "HumanEval/122", "prompt": "func add_elements: num arr: []num k: num", "canonical_solution": "sum := 0\nfor i := range arr[:k]\n    if (len (sprintf \"%v\" arr[i])) <= 2\n        sum = sum + arr[i]\n    end\nend\nreturn sum", "test": "func check candidate:any\n    assert -4 (candidate [1 -2 -3 41 57 76 87 88 99] 3)\n    assert 0 (candidate [111 121 3 4000 5 6] 2)\n    assert 125 (candidate [11 21 3 90 5 6 7 8 9] 4)\n    assert 24 (candidate [111 21 3 4000 5 6 7 8 9] 4) \"This prints if this assert fails 1 (good for debugging!)\"\n    assert 1 (candidate [1] 1) \"This prints if this assert fails 2 (also good for debugging!)\"\nend", "entry_point": "add_elements"}
{"task_id": "HumanEval/115", "prompt": "func max_fill: num grid: [][]num capacity: num", "canonical_solution": "import math\n\n    total := 0\n    for arr := range grid\n        total = total + math.ceil (sum arr / capacity)\n    end\n    return total", "test": "func check candidate:any\n\n    fails := 0\n    total := 0\n\n    func assert condition:bool message:string\n        total = total + 1\n        if not condition\n            fails = fails + 1\n            print \"Assertion failed:\" message\n        end\n    end\n\n    assert (candidate [[0 0 1 0] [0 1 0 0] [1 1 1 1]] 1) == 6 \"Error\"\n    assert (candidate [[0 0 1 1] [0 0 0 0] [1 1 1 1] [0 1 1 1]] 2) == 5 \"Error\"\n    assert (candidate [[0 0 0] [0 0 0]] 5) == 0 \"Error\"\n    assert (candidate [[1 1 1 1] [1 1 1 1]] 2) == 4 \"Error\"\n    assert (candidate [[1 1 1 1] [1 1 1 1]] 9) == 2 \"Error\"\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "max_fill"}
{"task_id": "HumanEval/120", "prompt": "func maximum:[]num arr:[]num k:num", "canonical_solution": "arr = sort arr\nans:[]num\nans = arr[-k:]\nreturn ans\nend", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert [-4 -3 5] (maximum [-3 -4 5] 3)\n    assert [4 4] (maximum [4 -4 4] 2)\n    assert [2] (maximum [-3 2 1 2 -1 -2 1] 1)\n    assert [2 20 123] (maximum [123 -123 20 0 1 2 -3] 3)\n    assert [0 1 2 20] (maximum [-123 20 0 1 2 -3] 4)\n    assert [-13 -8 0 0 3 5 15] (maximum [5 15 0 3 -13 -8 0] 7)\n    assert [3 5] (maximum [-1 0 2 5 3 -10] 2)\n    assert [5] (maximum [1 0 5 -7] 1)\n    assert [-4 4] (maximum [4 -4] 2)\n    assert [-10 10] (maximum [-10 10] 2)\n    assert [] (maximum [1 2 3 -23 243 -400 0] 0)\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "maximum"}
{"task_id": "HumanEval/103", "prompt": "func rounded_avg n:num m:num", "canonical_solution": "if m < n\n    return -1\nend\nsummation:num\nsummation = 0\nfor i := range n (m+1)\n    summation = summation + i\nend\nreturn sprintf \"0b%b\" (round (summation / (m - n + 1)))\nend", "test": "func check candidate:any\n    assert \"0b11\" (candidate 1 5)\n    assert \"0b1010\" (candidate 7 13)\n    assert \"0b1111001010\" (candidate 964 977)\n    assert \"0b1111100100\" (candidate 996 997)\n    assert \"0b1011000010\" (candidate 560 851)\n    assert \"0b101101110\" (candidate 185 546)\n    assert \"0b110101101\" (candidate 362 496)\n    assert \"0b1001110010\" (candidate 350 902)\n    assert \"0b11010111\" (candidate 197 233)\n    assert -1 (candidate 7 5)\n    assert -1 (candidate 5 1)\n    assert \"0b101\" (candidate 5 5)\nend", "entry_point": "rounded_avg"}
{"task_id": "HumanEval/123", "prompt": "func get_odd_collatz:[]num n:num", "canonical_solution": "if n % 2 == 0\n    odd_collatz:[]num\nelse\n    odd_collatz := [n]\nend\nwhile n > 1\n    if n % 2 == 0\n        n = n / 2\n    else\n        n = n * 3 + 1\n    end\n    if n % 2 == 1\n        odd_collatz = odd_collatz + [n]\n    end\nend\nreturn sort odd_collatz", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"This prints if this assert fails %v (good for debugging!)\\n\" want got\n        end\n    end\n    assert [1 5 7 11 13 17] (get_odd_collatz 14)\n    assert [1 5] (get_odd_collatz 5)\n    assert [1 3 5] (get_odd_collatz 12)\n    assert [1] (get_odd_collatz 1)\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "get_odd_collatz"}
{"task_id": "HumanEval/119", "prompt": "func match_parens: string lst: []string", "canonical_solution": "func check: bool s: string\n    val := 0\n    for i := range (len s)\n        if s[i] == \"(\"\n            val = val + 1\n        else\n            val = val - 1\n        end\n        if val < 0\n            return false\n        end\n    end\n    return val == 0\nend\n\nS1 := lst[0] + lst[1]\nS2 := lst[1] + lst[0]\nif check S1 or check S2\n    return \"Yes\"\nelse\n    return \"No\"\nend", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want: any got: any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert \"Yes\" (match_parens [\"()(\" \")\"])\n    assert \"No\" (match_parens [\")\" \")\"])\n    assert \"No\" (match_parens [\"(()(()\" \")())())\"])\n    assert \"Yes\" (match_parens [\")())\" \"(()()(\"])\n    assert \"Yes\" (match_parens [\"(())))\" \"(()())((\"])\n    assert \"No\" (match_parens [\"()\" \")())\"])\n    assert \"Yes\" (match_parens [\"(()(\" \"))))()\"])\n    assert \"No\" (match_parens [\"((((\" \"((())\"])\n    assert \"No\" (match_parens [\")(()\" \"(()(\"])\n    assert \"No\" (match_parens [\")(\" \")(\"])\n    assert \"Yes\" (match_parens [\"(\" \")\"])\n    assert \"Yes\" (match_parens [\")\" \"(\"])\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "match_parens"}
{"task_id": "HumanEval/128", "prompt": "func prod_signs: any arr: []num", "canonical_solution": "if (len arr) == 0\n    return false\nend\nprod := 0\nif has arr 0\n    prod = 0\nelse\n    neg_count := 0\n    for i := range arr\n        if arr[i] < 0\n            neg_count = neg_count + 1\n        end\n    end\n    if neg_count % 2 == 0\n        prod = 1\n    else\n        prod = -1\n    end\nend\nsum := 0\nfor i := range arr\n    sum = sum + abs arr[i]\nend\nreturn prod * sum\nend", "test": "func check candidate:any\n    assert -9 (candidate [1 2 2 -4])\n    assert 0 (candidate [0 1])\n    assert -10 (candidate [1 1 1 2 3 -1 1])\n    assert false (candidate [])\n    assert 20 (candidate [2 4 1 2 -1 -1 9])\n    assert 4 (candidate [-1 1 -1 1])\n    assert -4 (candidate [-1 1 1 1])\n    assert 0 (candidate [-1 1 1 0])\nend", "entry_point": "prod_signs"}
{"task_id": "HumanEval/125", "prompt": "func split_words:[]any txt:string", "canonical_solution": "if \" \" in txt\n    return txt.split()\nelse if \",\" in txt\n    return txt.replace(',', ' ').split()\nelse\n    count := 0\n    for c := range txt\n        if c.islower() and (ord c) % 2 == 0\n            count = count + 1\n        end\n    end\n    return count\nend", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n    assert [\"Hello\", \"world!\"] (split_words \"Hello world!\")\n    assert [\"Hello\", \"world!\"] (split_words \"Hello,world!\")\n    assert [\"Hello\", \"world,!\"] (split_words \"Hello world,!\")\n    assert [\"Hello,Hello,world\", \"!\"] (split_words \"Hello,Hello,world !\")\n    assert 3 (split_words \"abcdef\")\n    assert 2 (split_words \"aaabb\")\n    assert 1 (split_words \"aaaBb\")\n    assert 0 (split_words \"\")\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "split_words"}
{"task_id": "HumanEval/124", "prompt": "func valid_date:date_valid s:string", "canonical_solution": "date_valid := false\n    try\n        parts:[]string\n        parts = s.split \"-\"\n        if len parts != 3\n            return false\n        end\n        month:num\n        day:num\n        year:num\n        month = parts[0].(num)\n        day = parts[1].(num)\n        year = parts[2].(num)\n        if month < 1 or month > 12\n            return false\n        end\n        if month in [1 3 5 7 8 10 12] and (day < 1 or day > 31)\n            return false\n        end\n        if month in [4 6 9 11] and (day < 1 or day > 30)\n            return false\n        end\n        if month == 2 and (day < 1 or day > 29)\n            return false\n        end\n        date_valid = true\n    catch\n        date_valid = false\n    end\n    return date_valid", "test": "func check candidate:any\n    assert true (candidate \"03-11-2000\")\n    assert false (candidate \"15-01-2012\")\n    assert false (candidate \"04-0-2040\")\n    assert true (candidate \"06-04-2020\")\n    assert true (candidate \"01-01-2007\")\n    assert false (candidate \"03-32-2011\")\n    assert false (candidate \"\")\n    assert false (candidate \"04-31-3000\")\n    assert true (candidate \"06-06-2005\")\n    assert false (candidate \"21-31-2000\")\n    assert true (candidate \"04-12-2003\")\n    assert false (candidate \"04122003\")\n    assert false (candidate \"20030412\")\n    assert false (candidate \"2003-04\")\n    assert false (candidate \"2003-04-12\")\n    assert false (candidate \"04-2003\")\nend", "entry_point": "valid_date"}
{"task_id": "HumanEval/135", "prompt": "func canArrange:num arr:[]num", "canonical_solution": "ind := -1\ni := 1\nwhile i < (len arr)\n    if arr[i] < arr[i-1]\n        ind = i\n    end\n    i = i + 1\nend\nreturn ind", "test": "func check candidate:any\n    assert 3 (candidate [1 2 4 3 5])\n    assert -1 (candidate [1 2 4 5])\n    assert 2 (candidate [1 4 2 5 6 7 8 9 10])\n    assert 4 (candidate [4 8 5 7 3])\n    assert -1 (candidate [])\nend", "entry_point": "canArrange"}
{"task_id": "HumanEval/127", "prompt": "func intersection:interval1:[]num interval2:[]num", "canonical_solution": "l := max interval1[0] interval2[0]\nr := min interval1[1] interval2[1]\nlength := r - l\nif length > 0 and is_prime length\n    return \"YES\"\nend\nreturn \"NO\"\n\nfunc is_prime:num num\n    if num == 1 or num == 0\n        return false\n    end\n    if num == 2\n        return true\n    end\n    for i := range 2 num\n        if num % i == 0\n            return false\n        end\n    end\n    return true\nend", "test": "func check candidate:any\n    assert \"NO\" (candidate [1 2] [2 3])\n    assert \"NO\" (candidate [-1 1] [0 4])\n    assert \"YES\" (candidate [-3 -1] [-5 5])\n    assert \"YES\" (candidate [-2 2] [-4 0])\n    assert \"NO\" (candidate [-11 2] [-1 -1])\n    assert \"NO\" (candidate [1 2] [3 5])\n    assert \"NO\" (candidate [1 2] [1 2])\n    assert \"NO\" (candidate [-2 -2] [-3 -2])\nend", "entry_point": "intersection"}
{"task_id": "HumanEval/131", "prompt": "func digits:num n:num", "canonical_solution": "product := 1\nodd_count := 0\nfor digit := range (sprintf \"%v\" n)\n    int_digit := atoi digit\n    if int_digit % 2 == 1\n        product = product * int_digit\n        odd_count = odd_count + 1\n    end\nend\nif odd_count == 0\n    return 0\nelse\n    return product\nend", "test": "func check\n    fails := 0\ntotal := 0\nfunc assert want:any got:any\ntotal = total + 1\nif want != got\nfails = fails + 1\nprintf \"want != got: want %v got %v\\n\" want got\nend\nend\nassert 5 (digits 5)\nassert 5 (digits 54)\nassert 1 (digits 120)\nassert 5 (digits 5014)\nassert 315 (digits 98765)\nassert 2625 (digits 5576543)\nassert 0 (digits 2468)\nprintf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "digits"}
{"task_id": "HumanEval/126", "prompt": "func is_sorted:bool lst:[]num", "canonical_solution": "count_digit:{}num\nfor i := range lst\n    if has count_digit (sprintf \"%v\" lst[i])\n        count_digit[sprintf \"%v\" lst[i]] = count_digit[sprintf \"%v\" lst[i]] + 1\n    else\n        count_digit[sprintf \"%v\" lst[i]] = 1\n    end\nend\nfor i := range count_digit\n    if count_digit[i] > 2\n        return false\n    end\nend\nfor i := range 1 (len lst)\n    if lst[i-1] > lst[i]\n        return false\n    end\nend\nreturn true", "test": "func check:bool candidate:any\n    assert true (candidate [5])\n    assert true (candidate [1 2 3 4 5])\n    assert false (candidate [1 3 2 4 5])\n    assert true (candidate [1 2 3 4 5 6])\n    assert true (candidate [1 2 3 4 5 6 7])\n    assert false (candidate [1 3 2 4 5 6 7])\n    assert true (candidate [])\n    assert true (candidate [1])\n    assert false (candidate [3 2 1])\n    assert false (candidate [1 2 2 2 3 4])\n    assert false (candidate [1 2 3 3 3 4])\n    assert true (candidate [1 2 2 3 3 4])\n    assert true (candidate [1 2 3 4])\nend", "entry_point": "is_sorted"}
{"task_id": "HumanEval/133", "prompt": "func sum_squares: num lst: []num", "canonical_solution": "squared := 0\n    for i := range lst\n        squared = squared + ceil(lst[i])^2\n    end\n    return squared", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"This prints if this assert fails %v (good for debugging!)\\n\" want got\n        end\n    end\n\n    assert 14 (candidate [1 2 3])\n    assert 14 (candidate [1.0 2 3])\n    assert 84 (candidate [1 3 5 7])\n    assert 29 (candidate [1.4 4.2 0])\n    assert 6 (candidate [-2.4 1 1])\n    assert 10230 (candidate [100 1 15 2])\n    assert 200000000 (candidate [10000 10000])\n    assert 75 (candidate [-1.4 4.6 6.3])\n    assert 1086 (candidate [-1.4 17.9 18.9 19.9])\n    assert 0 (candidate [0])\n    assert 1 (candidate [-1])\n    assert 2 (candidate [-1 1 0])\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "sum_squares"}
{"task_id": "HumanEval/130", "prompt": "func tri:[]num n:num", "canonical_solution": "if n == 0\n    return [1]\nend\nmy_tri:[]num\nmy_tri = [1 3]\nfor i := range 2 (n + 1)\n    if i % 2 == 0\n        my_tri = my_tri + [i / 2 + 1]\n    else\n        my_tri = my_tri + [my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2]\n    end\nend\nreturn my_tri", "test": "func check candidate:any\n    assert [1 3 2.0 8.0] (candidate 3)\n    assert [1 3 2.0 8.0 3.0] (candidate 4)\n    assert [1 3 2.0 8.0 3.0 15.0] (candidate 5)\n    assert [1 3 2.0 8.0 3.0 15.0 4.0] (candidate 6)\n    assert [1 3 2.0 8.0 3.0 15.0 4.0 24.0] (candidate 7)\n    assert [1 3 2.0 8.0 3.0 15.0 4.0 24.0 5.0] (candidate 8)\n    assert [1 3 2.0 8.0 3.0 15.0 4.0 24.0 5.0 35.0] (candidate 9)\n    assert [1 3 2.0 8.0 3.0 15.0 4.0 24.0 5.0 35.0 6.0 48.0 7.0 63.0 8.0 80.0 9.0 99.0 10.0 120.0 11.0] (candidate 20)\n    assert [1] (candidate 0)\n    assert [1 3] (candidate 1)\nend", "entry_point": "tri"}
{"task_id": "HumanEval/137", "prompt": "func compareOne:any a:any b:any", "canonical_solution": "tempA:any\ntempB:any\ntempA = a\ntempB = b\nif (typeof tempA) == \"string\"\n    tempA = replace tempA \",\" \".\"\nend\nif (typeof tempB) == \"string\"\n    tempB = replace tempB \",\" \".\"\nend\nif tofloat tempA == tofloat tempB\n    return false\nend\nreturn a if tofloat tempA > tofloat tempB else b", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n    assert 2 (compareOne 1 2)\n    assert 2.5 (compareOne 1 2.5)\n    assert 3 (compareOne 2 3)\n    assert 6 (compareOne 5 6)\n    assert \"2,3\" (compareOne 1 \"2,3\")\n    assert \"6\" (compareOne \"5,1\" \"6\")\n    assert \"2\" (compareOne \"1\" \"2\")\n    assert false (compareOne \"1\" 1)\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "compareOne"}
{"task_id": "HumanEval/139", "prompt": "func special_factorial:num n:num", "canonical_solution": "fact_i := 1\nspecial_fact := 1\nfor i := range 1 (n+1)\n    fact_i = fact_i * i\n    special_fact = special_fact * fact_i\nend\nreturn special_fact", "test": "func check\n    fails := 0\ntotal := 0\n\nfunc assert want:any got:any\n    total = total + 1\n    if want != got\n        fails = fails + 1\n        printf \"Test failed: want %v got %v\\n\" want got\n    end\nend\n\n// -- Test Cases Start -- //\nassert 288 (special_factorial 4)\nassert 34560 (special_factorial 5)\nassert 125411328000 (special_factorial 7)\nassert 1 (special_factorial 1)\n// -- Test Cases End -- //\n\nif fails == 0\n    print \"All tests passed!\"\nelse\n    printf \"%v of %v tests failed.\\n\" fails total\nend\nend", "entry_point": "special_factorial"}
{"task_id": "HumanEval/138", "prompt": "func is_equal_to_sum_even:bool n:num", "canonical_solution": "return n % 2 == 0 and n >= 8", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert false (candidate 4)\n    assert false (candidate 6)\n    assert true (candidate 8)\n    assert true (candidate 10)\n    assert false (candidate 11)\n    assert true (candidate 12)\n    assert false (candidate 13)\n    assert true (candidate 16)\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "is_equal_to_sum_even"}
{"task_id": "HumanEval/134", "prompt": "func checkIfLastCharIsALetter:bool txt:string", "canonical_solution": "check := txt.split ' '[-1]\nreturn (len check) == 1 and (97 <= ord (check.lower)) <= 122", "test": "func check candidate:any\n    // Check some simple cases\n    assert false (candidate \"apple\")\n    assert true (candidate \"apple pi e\")\n    assert false (candidate \"eeeee\")\n    assert true (candidate \"A\")\n    assert false (candidate \"Pumpkin pie \")\n    assert false (candidate \"Pumpkin pie 1\")\n    assert false (candidate \"\")\n    assert false (candidate \"eeeee e \")\n    assert false (candidate \"apple pie\")\n    assert false (candidate \"apple pi e \")\n    // Check some edge cases that are easy to work out by hand.\n    assert true\nend", "entry_point": "checkIfLastCharIsALetter"}
{"task_id": "HumanEval/136", "prompt": "func largest_smallest_integers:[]any lst:[]num", "canonical_solution": "smallest:[]num\nlargest:[]num\nfor x := range lst\n    if x < 0\n        smallest = smallest + [x]\n    end\n    if x > 0\n        largest = largest + [x]\n    end\nend\nreturn [if (len smallest) > 0 max smallest else \"None\" if (len largest) > 0 min largest else \"None\"]", "test": "func check candidate:any\n    assert candidate [2 4 1 3 5 7] == [\"None\" 1]\n    assert candidate [2 4 1 3 5 7 0] == [\"None\" 1]\n    assert candidate [1 3 2 4 5 6 -2] == [-2 1]\n    assert candidate [4 5 3 6 2 7 -7] == [-7 2]\n    assert candidate [7 3 8 4 9 2 5 -9] == [-9 2]\n    assert candidate [] == [\"None\" \"None\"]\n    assert candidate [0] == [\"None\" \"None\"]\n    assert candidate [-1 -3 -5 -6] == [-1 \"None\"]\n    assert candidate [-1 -3 -5 -6 0] == [-1 \"None\"]\n    assert candidate [-6 -4 -4 -3 1] == [-3 1]\n    assert candidate [-6 -4 -4 -3 -100 1] == [-3 1]\nend", "entry_point": "largest_smallest_integers"}
{"task_id": "HumanEval/132", "prompt": "func is_nested:string s:string", "canonical_solution": "opening_bracket_index:[]num\nclosing_bracket_index:[]num\nfor i := range (len s)\n    if s[i] == '['\n        opening_bracket_index = opening_bracket_index + [i]\n    else\n        closing_bracket_index = closing_bracket_index + [i]\n    end\nend\nclosing_bracket_index = reverse closing_bracket_index\ncnt := 0\ni := 0\nl := len closing_bracket_index\nfor idx := range opening_bracket_index\n    if i < l and idx < closing_bracket_index[i]\n        cnt = cnt + 1\n        i = i + 1\n    end\nend\nreturn cnt >= 2", "test": "func check:bool candidate:func\n    assert true (candidate '[[]]')\n    assert false (candidate '[]]]]]]][[[[[]')\n    assert false (candidate '[][]')\n    assert false (candidate '[]')\n    assert true (candidate '[[[[]]]]')\n    assert false (candidate '[]]]]]]]]]]')\n    assert true (candidate '[][][[]]')\n    assert false (candidate '[[]')\n    assert false (candidate '[]]')\n    assert true (candidate '[[]][[')\n    assert true (candidate '[[][]]')\n    assert false (candidate '')\n    assert false (candidate '[[[[[[[[')\n    assert false (candidate ']]]]]]]]')\nend", "entry_point": "is_nested"}
{"task_id": "HumanEval/143", "prompt": "func words_in_sentence:sentence:string", "canonical_solution": "new_lst:[]string\n    for word := range sentence.split \" \"\n        flg := 0\n        if (len word) == 1\n            flg = 1\n        end\n        for i := range 2 (len word)\n            if (len word) % i == 0\n                flg = 1\n            end\n        end\n        if flg == 0 or (len word) == 2\n            new_lst = new_lst + [word]\n        end\n    end\n    return join new_lst \" \"", "test": "func check candidate:any\n    // Check some simple cases\n    assert \"is\" (candidate \"This is a test\")\n    assert \"go for\" (candidate \"lets go for swimming\")\n    assert \"there is no place\" (candidate \"there is no place available here\")\n    assert \"Hi am Hussein\" (candidate \"Hi I am Hussein\")\n    assert \"go for it\" (candidate \"go for it\")\n    // Check some edge cases that are easy to work out by hand.\n    assert \"\" (candidate \"here\")\n    assert \"is\" (candidate \"here is\")\nend\ncheck words_in_sentence", "entry_point": "words_in_sentence"}
{"task_id": "HumanEval/142", "prompt": "func sum_squares: num lst: []num", "canonical_solution": "result: []num\n    for i := range (len lst)\n        if i % 3 == 0\n            result = result + [lst[i] ** 2]\n        else if i % 4 == 0 and i % 3 != 0\n            result = result + [lst[i] ** 3]\n        else\n            result = result + [lst[i]]\n        end\n    end\n    return sum result", "test": "func check candidate:any\n    // Check some simple cases\n    assert 6 (candidate [1 2 3])\n    assert 14 (candidate [1 4 9])\n    assert 0 (candidate [])\n    assert 9 (candidate [1 1 1 1 1 1 1 1 1])\n    assert -3 (candidate [-1 -1 -1 -1 -1 -1 -1 -1 -1])\n    assert 0 (candidate [0])\n    assert -126 (candidate [-1 -5 2 -1 -5])\n    assert 3030 (candidate [-56 -99 1 0 -2])\n    assert 0 (candidate [-1 0 0 0 0 0 0 0 -1])\n    assert -14196 (candidate [-16 -9 -2 36 36 26 -20 25 -40 20 -4 12 -26 35 37])\n    assert -1448 (candidate [-1 -3 17 -1 -15 13 -1 14 -14 -12 -5 14 -14 6 13 11 16 16 4 10])\nend", "entry_point": "sum_squares"}
{"task_id": "HumanEval/146", "prompt": "func specialFilter: num nums: []num", "canonical_solution": "count := 0\n    for num := range nums\n        if num > 10\n            odd_digits := [1 3 5 7 9]\n            number_as_string := sprintf \"%v\" num\n            if (number_as_string[0].(num) in odd_digits) and (number_as_string[-1].(num) in odd_digits)\n                count = count + 1\n            end\n        end\n    end\n    return count", "test": "func check candidate:any\n    assert 0 (candidate [5 -2 1 -5])\n    assert 1 (candidate [15 -73 14 -15])\n    assert 2 (candidate [33 -2 -3 45 21 109])\n    assert 4 (candidate [43 -12 93 125 121 109])\n    assert 3 (candidate [71 -2 -33 75 21 19])\n    assert 0 (candidate [1])\n    assert 0 (candidate [])\nend", "entry_point": "specialFilter"}
{"task_id": "HumanEval/144", "prompt": "func simplify:bool x:string n:string", "canonical_solution": "a, b := x.split \"/\"\nc, d := n.split \"/\"\nnumerator := (a.(num)) * (c.(num))\ndenom := (b.(num)) * (d.(num))\nif numerator / denom == (numerator / denom).(num)\n    return true\nend\nreturn false", "test": "func check candidate:any\n    assert true (candidate \"1/5\" \"5/1\")\n    assert false (candidate \"1/6\" \"2/1\")\n    assert true (candidate \"5/1\" \"3/1\")\n    assert false (candidate \"7/10\" \"10/2\")\n    assert true (candidate \"2/10\" \"50/10\")\n    assert true (candidate \"7/2\" \"4/2\")\n    assert true (candidate \"11/6\" \"6/1\")\n    assert false (candidate \"2/3\" \"5/2\")\n    assert false (candidate \"5/2\" \"3/5\")\n    assert true (candidate \"2/4\" \"8/4\")\n    assert true (candidate \"2/4\" \"4/2\")\n    assert true (candidate \"1/5\" \"5/1\")\n    assert false (candidate \"1/5\" \"1/5\")\nend", "entry_point": "simplify"}
{"task_id": "HumanEval/141", "prompt": "func file_name_check: string file_name: string", "canonical_solution": "suf := [\"txt\" \"exe\" \"dll\"]\n    lst := file_name.split \".\"\n    if (len lst) != 2\n        return \"No\"\n    end\n    if not (lst[1] in suf)\n        return \"No\"\n    end\n    if (len lst[0]) == 0\n        return \"No\"\n    end\n    if not (lst[0][0].isalpha)\n        return \"No\"\n    end\n    t := len [x for x := range lst[0] if x.isdigit]\n    if t > 3\n        return \"No\"\n    end\n    return \"Yes\"", "test": "func check candidate:any\n    // Check some simple cases\n    assert \"Yes\" (candidate \"example.txt\")\n    assert \"No\" (candidate \"1example.dll\")\n    assert \"No\" (candidate 's1sdf3.asd')\n    assert \"Yes\" (candidate 'K.dll')\n    assert \"Yes\" (candidate 'MY16FILE3.exe')\n    assert \"No\" (candidate 'His12FILE94.exe')\n    assert \"No\" (candidate '_Y.txt')\n    assert \"No\" (candidate '?aREYA.exe')\n    assert \"No\" (candidate '/this_is_valid.dll')\n    assert \"No\" (candidate 'this_is_valid.wow')\n    assert \"Yes\" (candidate 'this_is_valid.txt')\n    assert \"No\" (candidate 'this_is_valid.txtexe')\n    assert \"No\" (candidate '#this2_i4s_5valid.ten')\n    assert \"No\" (candidate '@this1_is6_valid.exe')\n    assert \"No\" (candidate 'this_is_12valid.6exe4.txt')\n    assert \"No\" (candidate 'all.exe.txt')\n    assert \"Yes\" (candidate 'I563_No.exe')\n    assert \"Yes\" (candidate 'Is3youfault.txt')\n    assert \"Yes\" (candidate 'no_one#knows.dll')\n    assert \"No\" (candidate '1I563_Yes3.exe')\n    assert \"No\" (candidate 'I563_Yes3.txtt')\n    assert \"No\" (candidate 'final..txt')\n    assert \"No\" (candidate 'final132')\n    assert \"No\" (candidate '_f4indsartal132.')\n    // Check some edge cases that are easy to work out by hand.\n    assert \"No\" (candidate '.txt')\n    assert \"No\" (candidate 's.')\nend", "entry_point": "file_name_check"}
{"task_id": "HumanEval/150", "prompt": "func x_or_y:any n:num x:any y:any", "canonical_solution": "if n == 1\n    return y\nend\nfor i := range 2 n\n    if n % i == 0\n        return y\n        break\n    end\nend\nreturn x", "test": "func check\n    assert 34 (x_or_y 7 34 12)\n    assert 5 (x_or_y 15 8 5)\n    assert 33 (x_or_y 3 33 5212)\n    assert 3 (x_or_y 1259 3 52)\n    assert -1 (x_or_y 7919 -1 12)\n    assert 583 (x_or_y 3609 1245 583)\n    assert 129 (x_or_y 91 56 129)\n    assert 1234 (x_or_y 6 34 1234)\n    assert 0 (x_or_y 1 2 0)\n    assert 2 (x_or_y 2 2 0)\nend", "entry_point": "x_or_y"}
{"task_id": "HumanEval/148", "prompt": "func bf:[]string planet1:string planet2:string", "canonical_solution": "planet_names := [\"Mercury\" \"Venus\" \"Earth\" \"Mars\" \"Jupiter\" \"Saturn\" \"Uranus\" \"Neptune\"]\n    if not (planet1 in planet_names) or not (planet2 in planet_names) or planet1 == planet2\n        return []\n    end\n    planet1_index := index planet_names planet1\n    planet2_index := index planet_names planet2\n    if planet1_index < planet2_index\n        return planet_names[planet1_index + 1: planet2_index]\n    else\n        return planet_names[planet2_index + 1: planet1_index]\n    end", "test": "func check candidate:any\n    assert [\"Saturn\" \"Uranus\"] (candidate \"Jupiter\" \"Neptune\")\n    assert [\"Venus\"] (candidate \"Earth\" \"Mercury\")\n    assert [\"Venus\" \"Earth\" \"Mars\" \"Jupiter\" \"Saturn\"] (candidate \"Mercury\" \"Uranus\")\n    assert [\"Earth\" \"Mars\" \"Jupiter\" \"Saturn\" \"Uranus\"] (candidate \"Neptune\" \"Venus\")\n    assert [] (candidate \"Earth\" \"Earth\")\n    assert [] (candidate \"Mars\" \"Earth\")\n    assert [] (candidate \"Jupiter\" \"Makemake\")\nend", "entry_point": "bf"}
{"task_id": "HumanEval/129", "prompt": "func minPath:[]num grid:[][]num k:num", "canonical_solution": "n := len grid\nval := n * n + 1\nfor i := range n\n    for j := range n\n        if grid[i][j] == 1\n            temp:[]num\n            if i != 0\n                temp = temp + [grid[i - 1][j]]\n            end\n            if j != 0\n                temp = temp + [grid[i][j - 1]]\n            end\n            if i != n - 1\n                temp = temp + [grid[i + 1][j]]\n            end\n            if j != n - 1\n                temp = temp + [grid[i][j + 1]]\n            end\n            val = min temp\n        end\n    end\nend\nans:[]num\nfor i := range k\n    if i % 2 == 0\n        ans = ans + [1]\n    else\n        ans = ans + [val]\n    end\nend\nreturn ans", "test": "func check candidate:any\n    assert [1 2 1] (candidate [[1 2 3] [4 5 6] [7 8 9]] 3)\n    assert [1] (candidate [[5 9 3] [4 1 6] [7 8 2]] 1)\n    assert [1 2 1 2] (candidate [[1 2 3 4] [5 6 7 8] [9 10 11 12] [13 14 15 16]] 4)\n    assert [1 10 1 10 1 10 1] (candidate [[6 4 13 10] [5 7 12 1] [3 16 11 15] [8 14 9 2]] 7)\n    assert [1 7 1 7 1] (candidate [[8 14 9 2] [6 4 13 15] [5 7 1 12] [3 10 11 16]] 5)\n    assert [1 6 1 6 1 6 1 6 1] (candidate [[11 8 7 2] [5 16 14 4] [9 3 15 6] [12 13 10 1]] 9)\n    assert [1 6 1 6 1 6 1 6 1 6 1 6] (candidate [[12 13 10 1] [9 3 15 6] [5 16 14 4] [11 8 7 2]] 12)\n    assert [1 3 1 3 1 3 1 3] (candidate [[2 7 4] [3 1 5] [6 8 9]] 8)\n    assert [1 5 1 5 1 5 1 5] (candidate [[6 1 5] [3 8 9] [2 7 4]] 8)\n    assert [1 2 1 2 1 2 1 2 1 2] (candidate [[1 2] [3 4]] 10)\n    assert [1 3 1 3 1 3 1 3 1 3] (candidate [[1 3] [3 2]] 10)\nend", "entry_point": "minPath"}
{"task_id": "HumanEval/147", "prompt": "func getMaxTriples:num n:num", "canonical_solution": "A:[]num\n    for i := range 1 (n + 1)\n        A = A + [i * i - i + 1]\n    end\n    ans:[]any\n    for i := range n\n        for j := range (i + 1) n\n            for k := range (j + 1) n\n                if (A[i] + A[j] + A[k]) % 3 == 0\n                    ans = ans + [(A[i] A[j] A[k])]\n                end\n            end\n        end\n    end\n    return len ans", "test": "func check:num candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert 1 (candidate 5)\n    assert 4 (candidate 6)\n    assert 36 (candidate 10)\n    assert 53361 (candidate 100)\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "getMaxTriples"}
{"task_id": "HumanEval/140", "prompt": "func fix_spaces:string text:string", "canonical_solution": "\n    new_text:string\n    i:num\n    start:num\n    end:num\n    i = 0\n    start = 0\n    end = 0\n    while i < len text\n        if text[i] == \" \"\n            end = end + 1\n        else\n            if end - start > 2\n                new_text = new_text + \"-\" + text[i]\n            elif end - start > 0\n                new_text = new_text + \"_\" * (end - start) + text[i]\n            else\n                new_text = new_text + text[i]\n            end\n            start = i + 1\n            end = i + 1\n        end\n        i = i + 1\n    end\n    if end - start > 2\n        new_text = new_text + \"-\"\n    elif end - start > 0\n        new_text = new_text + \"_\"\n    end\n    return new_text\nend", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"This prints if this assert fails %v (good for debugging!)\\n\" (total - fails)\n        end\n    end\n    assert \"Example\" (fix_spaces \"Example\")\n    assert \"Mudasir_Hanif_\" (fix_spaces \"Mudasir Hanif \")\n    assert \"Yellow_Yellow__Dirty__Fellow\" (fix_spaces \"Yellow Yellow  Dirty  Fellow\")\n    assert \"Exa-mple\" (fix_spaces \"Exa   mple\")\n    assert \"-Exa_1_2_2_mple\" (fix_spaces \"   Exa 1 2 2 mple\")\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "fix_spaces"}
{"task_id": "HumanEval/149", "prompt": "func list_sort:[]string lst:[]string", "canonical_solution": "lst = sort lst\n    new_lst:[]string\n    for i := range (len lst)\n        if (len lst[i]) % 2 == 0\n            new_lst = new_lst + [lst[i]]\n        end\n    end\n    new_lst = sort new_lst by (len $)\n    return new_lst", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert [\"aa\"] (candidate [\"aa\" \"a\" \"aaa\"])\n    assert [\"AI\" \"asdf\" \"school\"] (candidate [\"school\" \"AI\" \"asdf\" \"b\"])\n    assert [] (candidate [\"d\" \"b\" \"c\" \"a\"])\n    assert [\"abcd\" \"dcba\"] (candidate [\"d\" \"dcba\" \"abcd\" \"a\"])\n    assert [\"AI\" \"ai\" \"au\"] (candidate [\"AI\" \"ai\" \"au\"])\n    assert [] (candidate [\"a\" \"b\" \"b\" \"c\" \"c\" \"a\"])\n    assert [\"cc\" \"dd\" \"aaaa\" \"bbbb\"] (candidate ['aaaa' 'bbbb' 'dd' 'cc'])\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "list_sort"}
{"task_id": "HumanEval/145", "prompt": "func orderByPoints:[]num nums:[]num", "canonical_solution": "func digitsSum:num n:num\n    neg := 1\n    if n < 0\n        n = -1 * n\n        neg = -1\n    end\n    nStr := sprintf \"%v\" n\n    nArr:[]num\n    for i := range (len nStr)\n        nArr = nArr + [num(nStr[i])]\n    end\n    nArr[0] = nArr[0] * neg\n    return sum nArr\nend\n\nreturn sort nums (func(a:num b:num):num\n    aSum := digitsSum a\n    bSum := digitsSum b\n    if aSum < bSum\n        return -1\n    else if aSum > bSum\n        return 1\n    end\n    return 0\nend)", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"want != got: want %v got %v\\n\" want got\n        end\n    end\n\n    assert [-1 -11 1 -12 11] (orderByPoints [1 11 -1 -11 -12])\n    assert [0 2 3 6 53 423 423 423 1234 145 37 46 56 463 3457] (orderByPoints [1234 423 463 145 2 423 423 53 6 37 3457 3 56 0 46])\n    assert [] (orderByPoints [])\n    assert [-3 -32 -98 -11 1 2 43 54] (orderByPoints [1 -11 -32 43 54 -98 2 -3])\n    assert [1 10 2 11 3 4 5 6 7 8 9] (orderByPoints [1 2 3 4 5 6 7 8 9 10 11])\n    assert [-76 -21 0 4 23 6 6] (orderByPoints [0 6 6 -76 -21 23 4])\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "orderByPoints"}
{"task_id": "HumanEval/152", "prompt": "func compare:[]num game:[]num guess:[]num", "canonical_solution": "res:[]num\n    for i := range (len game)\n        res = res + [abs(game[i] - guess[i])]\n    end\n    return res\nend", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"This prints if this assert fails %v (good for debugging!)\\n\" (total - fails)\n        end\n    end\n\n    assert [0 0 0 0 3 3] (candidate [1 2 3 4 5 1] [1 2 3 4 2 -2])\n    assert [0 0 0 0 0 0] (candidate [0 0 0 0 0 0] [0 0 0 0 0 0])\n    assert [2 4 6] (candidate [1 2 3] [-1 -2 -3])\n    assert [2 0 0 1] (candidate [1 2 3 5] [-1 2 3 4])\n\n    if fails == 0\n        print \"All tests passed!\"\n    else\n        printf \"%v of %v tests passed\\n\" (total - fails) total\n    end\nend", "entry_point": "compare"}
{"task_id": "HumanEval/155", "prompt": "func even_odd_count:num num:num", "canonical_solution": "even_count := 0\nodd_count := 0\nfor i := range (sprintf \"%v\" (abs num))\n    if (num(i) % 2) == 0\n        even_count = even_count + 1\n    else\n        odd_count = odd_count + 1\n    end\nend\nreturn [even_count odd_count]", "test": "func check candidate:any\n    assert [0 1] (candidate 7)\n    assert [1 1] (candidate -78)\n    assert [2 2] (candidate 3452)\n    assert [3 3] (candidate 346211)\n    assert [3 3] (candidate -345821)\n    assert [1 0] (candidate -2)\n    assert [2 3] (candidate -45347)\n    assert [1 0] (candidate 0)\n    assert true\nend", "entry_point": "even_odd_count"}
{"task_id": "HumanEval/154", "prompt": "func cycpattern_check:bool a:string b:string", "canonical_solution": "l := len b\n    pat := b + b\n    for i := range (len a) - l + 1\n        for j := range l + 1\n            if a[i:i+l] == pat[j:j+l]\n                return true\n            end\n        end\n    end\n    return false", "test": "func check candidate:any\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"test #%v failed: expected %v, got %v\\n\" (total - 1) want got\n        end\n    end\n\n    assert false (candidate \"xyzw\" \"xyw\")\n    assert true (candidate \"yello\" \"ell\")\n    assert false (candidate \"whattup\" \"ptut\")\n    assert true (candidate \"efef\" \"fee\")\n    assert false (candidate \"abab\" \"aabb\")\n    assert true (candidate \"winemtt\" \"tinem\")\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "cycpattern_check"}
{"task_id": "HumanEval/162", "prompt": "func string_to_md5:text:string", "canonical_solution": "if text == \"\"\n    return \"null\"\nend\nreturn md5 text", "test": "func check candidate:any\n    assert \"3e25960a79dbc69b674cd4ec67a72c62\" (candidate \"Hello world\")\n    assert \"null\" (candidate \"\")\n    assert \"0ef78513b0cb8cef12743f5aeb35f888\" (candidate \"A B C\")\n    assert \"5f4dcc3b5aa765d61d8327deb882cf99\" (candidate \"password\")\nend", "entry_point": "string_to_md5"}
{"task_id": "HumanEval/157", "prompt": "func right_angle_triangle:bool a:num b:num c:num", "canonical_solution": "return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b", "test": "func check candidate:any\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"This prints if this assert fails %v (good for debugging!)\\n\" (total - fails)\n        end\n    end\n    assert true (candidate 3 4 5)\n    assert false (candidate 1 2 3)\n    assert true (candidate 10 6 8)\n    assert false (candidate 2 2 2)\n    assert true (candidate 7 24 25)\n    assert false (candidate 10 5 7)\n    assert true (candidate 5 12 13)\n    assert true (candidate 15 8 17)\n    assert true (candidate 48 55 73)\n    assert false (candidate 1 1 1)\n    assert false (candidate 2 2 10)\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "right_angle_triangle"}
{"task_id": "HumanEval/159", "prompt": "func eat:[]num number:num need:num remaining:num", "canonical_solution": "\n    if need <= remaining\n        return [number + need, remaining - need]\n    else\n        return [number + remaining, 0]\n    end\n", "test": "func check candidate:any\n\n    // Check some simple cases\n    assert [11, 4] (candidate 5 6 10)\n    assert [12, 1] (candidate 4 8 9)\n    assert [11, 0] (candidate 1 10 10)\n    assert [7, 0] (candidate 2 11 5)\n\n    // Check some edge cases that are easy to work out by hand.\n    assert [9, 2] (candidate 4 5 7)\n    assert [5, 0] (candidate 4 5 1)\n\nend", "entry_point": "eat"}
{"task_id": "HumanEval/163", "prompt": "func generate_integers:[]num a:num b:num", "canonical_solution": "lower := max 2 (min a b)\nupper := min 8 (max a b)\nresult:[]num\nfor i := range lower (upper+1)\n    if i % 2 == 0\n        result = result + [i]\n    end\nend\nreturn result", "test": "func check candidate:any\n    assert [2 4 6 8] (candidate 2 10) \"Test 1\"\n    assert [2 4 6 8] (candidate 10 2) \"Test 2\"\n    assert [2 4 6 8] (candidate 132 2) \"Test 3\"\n    assert [] (candidate 17 89) \"Test 4\"\n    assert true \"This prints if this assert fails 2 (also good for debugging!)\"\nend", "entry_point": "generate_integers"}
{"task_id": "HumanEval/153", "prompt": "func Strongest_Extension:string class_name:string extensions:[]string", "canonical_solution": "strong := extensions[0]\nmy_val := len([x for x := range extensions[0] if x.isalpha() and x.isupper()]) - len([x for x := range extensions[0] if x.isalpha() and x.islower()])\nfor s := range extensions\n    val := len([x for x := range s if x.isalpha() and x.isupper()]) - len([x for x := range s if x.isalpha() and x.islower()])\n    if val > my_val\n        strong = s\n        my_val = val\n    end\nend\nans := class_name + \".\" + strong\nreturn ans", "test": "func check candidate:any\n    assert candidate('Watashi' ['tEN' 'niNE' 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123' ['nani' 'NazeDa' 'YEs.WeCaNe' '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE' ['t' 'eMptY' 'nothing' 'zeR00' 'NuLl__' '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K' ['Ta' 'TAR' 't234An' 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA' ['Tab' '123' '781345' '-_-']) == '__HAHA.123'\n    assert candidate('YameRore' ['HhAas' 'okIWILL123' 'WorkOut' 'Fails' '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly' ['Die' 'NowW' 'Wow' 'WoW']) == 'finNNalLLly.WoW'\n    assert candidate('_' ['Bb' '91245']) == '_.Bb'\n    assert candidate('Sp' ['671235' 'Bb']) == 'Sp.671235'\nend\ncheck Strongest_Extension", "entry_point": "Strongest_Extension"}
{"task_id": "HumanEval/160", "prompt": "func do_algebra: num operator:[]string operand:[]num", "canonical_solution": "expression:string\nexpression = sprintf \"%v\" operand[0]\nfor i := range (len operator)\n    expression = expression + operator[i] + sprintf \"%v\" operand[i+1]\nend\nreturn eval expression", "test": "func check\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"This prints if this assert fails %v (good for debugging!)\\n\" (total - 1)\n        end\n    end\n    assert 37 (do_algebra [\"**\" \"*\" \"+\"] [2 3 4 5])\n    assert 9 (do_algebra [\"+\" \"*\" \"-\"] [2 3 4 5])\n    assert 8 (do_algebra [\"//\" \"*\"] [7 3 4])\n    assert true\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "do_algebra"}
{"task_id": "HumanEval/161", "prompt": "func solve:string s:string", "canonical_solution": "flg := 0\nidx := 0\nnew_str:[]string\nfor i := range (len s)\n    if (s[i].isalpha)\n        new_str = new_str + [s[i].swapcase]\n        flg = 1\n    else\n        new_str = new_str + [s[i]]\n    end\nend\ns := \"\"\nfor i := range (len new_str)\n    s = s + new_str[i]\nend\nif flg == 0\n    s = s[::-1]\nend\nreturn s", "test": "func check\n    fails := 0\ntotal := 0\nfunc assert want:any got:any\ntotal = total + 1\nif want != got\nfails = fails + 1\nprintf \"want != got: want %v got %v\\n\" want got\nend\nend\nassert \"aSdF\" (solve \"AsDf\")\nassert \"4321\" (solve \"1234\")\nassert \"AB\" (solve \"ab\")\nassert \"#A@c\" (solve \"#a@C\")\nassert \"#aSDFw^45\" (solve \"#AsdfW^45\")\nassert \"2@6#\" (solve \"#6@2\")\nassert \"#$A^d\" (solve \"#$a^D\")\nassert \"#CCC\" (solve \"#ccc\")\nprintf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "solve"}
{"task_id": "HumanEval/158", "prompt": "func find_max:string words:[]string", "canonical_solution": "max_word:string\nmax_word = sorted words (func a:string b:string\n    if (len (set a)) == (len (set b))\n        return a < b\n    end\n    return (len (set a)) > (len (set b))\nend)[0]\nreturn max_word", "test": "func check\n    fails := 0\n    total := 0\n\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"assertion failed: want %v got %v\\n\" want got\n        end\n    end\n\n    assert \"string\" (find_max [\"name\" \"of\" \"string\"])\n    assert \"enam\" (find_max [\"name\" \"enam\" \"game\"])\n    assert \"aaaaaaa\" (find_max [\"aaaaaaa\" \"bb\" \"cc\"])\n    assert \"abc\" (find_max [\"abc\" \"cba\"])\n    assert \"footbott\" (find_max [\"play\" \"this\" \"game\" \"of\" \"footbott\"])\n    assert \"gonna\" (find_max [\"we\" \"are\" \"gonna\" \"rock\"])\n    assert \"nation\" (find_max [\"we\" \"are\" \"a\" \"mad\" \"nation\"])\n    assert \"this\" (find_max [\"this\" \"is\" \"a\" \"prrk\"])\n    assert \"b\" (find_max [\"b\"])\n    assert \"play\" (find_max [\"play\" \"play\" \"play\"])\n\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "find_max"}
{"task_id": "HumanEval/156", "prompt": "func intToMiniRoman:string number:num", "canonical_solution": "num:[]num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\nsym:[]string = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"]\ni := 12\nres:string = \"\"\nwhile number > 0\n    div := number // num[i]\n    number = number % num[i]\n    while div > 0\n        res = res + sym[i]\n        div = div - 1\n    end\n    i = i - 1\nend\nreturn res.lower()", "test": "func check\n    fails := 0\ntotal := 0\nfunc assert want:any got:any\ntotal = total + 1\nif want != got\nfails = fails + 1\nprintf \"want != got: want %v got %v\\n\" want got\nend\nend\nassert \"xix\" (intToMiniRoman 19)\nassert \"clii\" (intToMiniRoman 152)\nassert \"ccli\" (intToMiniRoman 251)\nassert \"cdxxvi\" (intToMiniRoman 426)\nassert \"d\" (intToMiniRoman 500)\nassert \"i\" (intToMiniRoman 1)\nassert \"iv\" (intToMiniRoman 4)\nassert \"xliii\" (intToMiniRoman 43)\nassert \"xc\" (intToMiniRoman 90)\nassert \"xciv\" (intToMiniRoman 94)\nassert \"dxxxii\" (intToMiniRoman 532)\nassert \"cm\" (intToMiniRoman 900)\nassert \"cmxciv\" (intToMiniRoman 994)\nassert \"m\" (intToMiniRoman 1000)\nprintf \"%v of %v tests passed\\n\" (total - fails) total\nend\ncheck", "entry_point": "intToMiniRoman"}
{"task_id": "HumanEval/151", "prompt": "func doubleTheDifference: num lst: []num", "canonical_solution": "return sum [i * i for i := range lst if i > 0 and i % 2 != 0 and typeof i == \"num\"]", "test": "func check candidate:any\n    fails := 0\n    total := 0\n    func assert want:any got:any\n        total = total + 1\n        if want != got\n            fails = fails + 1\n            printf \"This prints if this assert fails %v (good for debugging!)\\n\" total\n        end\n    end\n    assert 0 (candidate [])\n    assert 25 (candidate [5 4])\n    assert 0 (candidate [0.1 0.2 0.3])\n    assert 0 (candidate [-10 -20 -30])\n    assert 0 (candidate [-1 -2 8])\n    assert 34 (candidate [0.2 3 5])\n    lst := range -99 100 2\n    odd_sum := sum [i * i for i := range lst if i % 2 != 0 and i > 0]\n    assert odd_sum (candidate lst)\n    printf \"%v of %v tests passed\\n\" (total - fails) total\nend", "entry_point": "doubleTheDifference"}
